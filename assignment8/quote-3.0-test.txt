diff -pru diffutils-3.0/analyze.c diffutils-3.0-patch/analyze.c
--- diffutils-3.0/analyze.c	2020-05-30 16:24:16.366948000 -0700
+++ diffutils-3.0-patch/analyze.c	2020-05-30 15:52:03.047081000 -0700
@@ -1,7 +1,7 @@
 /* Analyze file differences for GNU DIFF.
 
    Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
-   2009-2013, 2015-2020 Free Software Foundation, Inc.
+   2009-2010 Free Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -57,7 +57,7 @@ discard_confusing_lines (struct file_dat
 
   /* Allocate our results.  */
   p = xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
-               * (2 * sizeof *p));
+	       * (2 * sizeof *p));
   for (f = 0; f < 2; f++)
     {
       filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
@@ -79,7 +79,7 @@ discard_confusing_lines (struct file_dat
   /* Set up tables of which lines are going to be discarded.  */
 
   discarded[0] = zalloc (filevec[0].buffered_lines
-                         + filevec[1].buffered_lines);
+			 + filevec[1].buffered_lines);
   discarded[1] = discarded[0] + filevec[0].buffered_lines;
 
   /* Mark to be discarded each line that matches no line of the other file.
@@ -95,21 +95,21 @@ discard_confusing_lines (struct file_dat
       size_t tem = end / 64;
 
       /* Multiply MANY by approximate square root of number of lines.
-         That is the threshold for provisionally discardable lines.  */
+	 That is the threshold for provisionally discardable lines.  */
       while ((tem = tem >> 2) > 0)
-        many *= 2;
+	many *= 2;
 
       for (i = 0; i < end; i++)
-        {
-          lin nmatch;
-          if (equivs[i] == 0)
-            continue;
-          nmatch = counts[equivs[i]];
-          if (nmatch == 0)
-            discards[i] = 1;
-          else if (nmatch > many)
-            discards[i] = 2;
-        }
+	{
+	  lin nmatch;
+	  if (equivs[i] == 0)
+	    continue;
+	  nmatch = counts[equivs[i]];
+	  if (nmatch == 0)
+	    discards[i] = 1;
+	  else if (nmatch > many)
+	    discards[i] = 2;
+	}
     }
 
   /* Don't really discard the provisional lines except when they occur
@@ -122,106 +122,106 @@ discard_confusing_lines (struct file_dat
       register char *discards = discarded[f];
 
       for (i = 0; i < end; i++)
-        {
-          /* Cancel provisional discards not in middle of run of discards.  */
-          if (discards[i] == 2)
-            discards[i] = 0;
-          else if (discards[i] != 0)
-            {
-              /* We have found a nonprovisional discard.  */
-              register lin j;
-              lin length;
-              lin provisional = 0;
-
-              /* Find end of this run of discardable lines.
-                 Count how many are provisionally discardable.  */
-              for (j = i; j < end; j++)
-                {
-                  if (discards[j] == 0)
-                    break;
-                  if (discards[j] == 2)
-                    ++provisional;
-                }
-
-              /* Cancel provisional discards at end, and shrink the run.  */
-              while (j > i && discards[j - 1] == 2)
-                discards[--j] = 0, --provisional;
-
-              /* Now we have the length of a run of discardable lines
-                 whose first and last are not provisional.  */
-              length = j - i;
-
-              /* If 1/4 of the lines in the run are provisional,
-                 cancel discarding of all provisional lines in the run.  */
-              if (provisional * 4 > length)
-                {
-                  while (j > i)
-                    if (discards[--j] == 2)
-                      discards[j] = 0;
-                }
-              else
-                {
-                  register lin consec;
-                  lin minimum = 1;
-                  lin tem = length >> 2;
-
-                  /* MINIMUM is approximate square root of LENGTH/4.
-                     A subrun of two or more provisionals can stand
-                     when LENGTH is at least 16.
-                     A subrun of 4 or more can stand when LENGTH >= 64.  */
-                  while (0 < (tem >>= 2))
-                    minimum <<= 1;
-                  minimum++;
-
-                  /* Cancel any subrun of MINIMUM or more provisionals
-                     within the larger run.  */
-                  for (j = 0, consec = 0; j < length; j++)
-                    if (discards[i + j] != 2)
-                      consec = 0;
-                    else if (minimum == ++consec)
-                      /* Back up to start of subrun, to cancel it all.  */
-                      j -= consec;
-                    else if (minimum < consec)
-                      discards[i + j] = 0;
-
-                  /* Scan from beginning of run
-                     until we find 3 or more nonprovisionals in a row
-                     or until the first nonprovisional at least 8 lines in.
-                     Until that point, cancel any provisionals.  */
-                  for (j = 0, consec = 0; j < length; j++)
-                    {
-                      if (j >= 8 && discards[i + j] == 1)
-                        break;
-                      if (discards[i + j] == 2)
-                        consec = 0, discards[i + j] = 0;
-                      else if (discards[i + j] == 0)
-                        consec = 0;
-                      else
-                        consec++;
-                      if (consec == 3)
-                        break;
-                    }
-
-                  /* I advances to the last line of the run.  */
-                  i += length - 1;
-
-                  /* Same thing, from end.  */
-                  for (j = 0, consec = 0; j < length; j++)
-                    {
-                      if (j >= 8 && discards[i - j] == 1)
-                        break;
-                      if (discards[i - j] == 2)
-                        consec = 0, discards[i - j] = 0;
-                      else if (discards[i - j] == 0)
-                        consec = 0;
-                      else
-                        consec++;
-                      if (consec == 3)
-                        break;
-                    }
-                }
-            }
-        }
+	{
+	  /* Cancel provisional discards not in middle of run of discards.  */
+	  if (discards[i] == 2)
+	    discards[i] = 0;
+	  else if (discards[i] != 0)
+	    {
+	      /* We have found a nonprovisional discard.  */
+	      register lin j;
+	      lin length;
+	      lin provisional = 0;
+
+	      /* Find end of this run of discardable lines.
+		 Count how many are provisionally discardable.  */
+	      for (j = i; j < end; j++)
+		{
+		  if (discards[j] == 0)
+		    break;
+		  if (discards[j] == 2)
+		    ++provisional;
+		}
+
+	      /* Cancel provisional discards at end, and shrink the run.  */
+	      while (j > i && discards[j - 1] == 2)
+		discards[--j] = 0, --provisional;
+
+	      /* Now we have the length of a run of discardable lines
+		 whose first and last are not provisional.  */
+	      length = j - i;
+
+	      /* If 1/4 of the lines in the run are provisional,
+		 cancel discarding of all provisional lines in the run.  */
+	      if (provisional * 4 > length)
+		{
+		  while (j > i)
+		    if (discards[--j] == 2)
+		      discards[j] = 0;
+		}
+	      else
+		{
+		  register lin consec;
+		  lin minimum = 1;
+		  lin tem = length >> 2;
+
+		  /* MINIMUM is approximate square root of LENGTH/4.
+		     A subrun of two or more provisionals can stand
+		     when LENGTH is at least 16.
+		     A subrun of 4 or more can stand when LENGTH >= 64.  */
+		  while (0 < (tem >>= 2))
+		    minimum <<= 1;
+		  minimum++;
+
+		  /* Cancel any subrun of MINIMUM or more provisionals
+		     within the larger run.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    if (discards[i + j] != 2)
+		      consec = 0;
+		    else if (minimum == ++consec)
+		      /* Back up to start of subrun, to cancel it all.  */
+		      j -= consec;
+		    else if (minimum < consec)
+		      discards[i + j] = 0;
+
+		  /* Scan from beginning of run
+		     until we find 3 or more nonprovisionals in a row
+		     or until the first nonprovisional at least 8 lines in.
+		     Until that point, cancel any provisionals.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i + j] == 1)
+			break;
+		      if (discards[i + j] == 2)
+			consec = 0, discards[i + j] = 0;
+		      else if (discards[i + j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+
+		  /* I advances to the last line of the run.  */
+		  i += length - 1;
+
+		  /* Same thing, from end.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i - j] == 1)
+			break;
+		      if (discards[i - j] == 2)
+			consec = 0, discards[i - j] = 0;
+		      else if (discards[i - j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+		}
+	    }
+	}
     }
 
   /* Actually discard the lines. */
@@ -231,13 +231,13 @@ discard_confusing_lines (struct file_dat
       lin end = filevec[f].buffered_lines;
       lin j = 0;
       for (i = 0; i < end; ++i)
-        if (minimal || discards[i] == 0)
-          {
-            filevec[f].undiscarded[j] = filevec[f].equivs[i];
-            filevec[f].realindexes[j++] = i;
-          }
-        else
-          filevec[f].changed[i] = 1;
+	if (minimal || discards[i] == 0)
+	  {
+	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
+	    filevec[f].realindexes[j++] = i;
+	  }
+	else
+	  filevec[f].changed[i] = 1;
       filevec[f].nondiscarded_lines = j;
     }
 
@@ -270,85 +270,85 @@ shift_boundaries (struct file_data filev
       lin i_end = filevec[f].buffered_lines;
 
       while (1)
-        {
-          lin runlength, start, corresponding;
+	{
+	  lin runlength, start, corresponding;
 
-          /* Scan forwards to find beginning of another run of changes.
-             Also keep track of the corresponding point in the other file.  */
+	  /* Scan forwards to find beginning of another run of changes.
+	     Also keep track of the corresponding point in the other file.  */
 
-          while (i < i_end && !changed[i])
-            {
-              while (other_changed[j++])
-                continue;
-              i++;
-            }
-
-          if (i == i_end)
-            break;
-
-          start = i;
-
-          /* Find the end of this run of changes.  */
-
-          while (changed[++i])
-            continue;
-          while (other_changed[j])
-            j++;
-
-          do
-            {
-              /* Record the length of this run of changes, so that
-                 we can later determine whether the run has grown.  */
-              runlength = i - start;
-
-              /* Move the changed region back, so long as the
-                 previous unchanged line matches the last changed one.
-                 This merges with previous changed regions.  */
-
-              while (start && equivs[start - 1] == equivs[i - 1])
-                {
-                  changed[--start] = 1;
-                  changed[--i] = 0;
-                  while (changed[start - 1])
-                    start--;
-                  while (other_changed[--j])
-                    continue;
-                }
-
-              /* Set CORRESPONDING to the end of the changed run, at the last
-                 point where it corresponds to a changed run in the other file.
-                 CORRESPONDING == I_END means no such point has been found.  */
-              corresponding = other_changed[j - 1] ? i : i_end;
-
-              /* Move the changed region forward, so long as the
-                 first changed line matches the following unchanged one.
-                 This merges with following changed regions.
-                 Do this second, so that if there are no merges,
-                 the changed region is moved forward as far as possible.  */
-
-              while (i != i_end && equivs[start] == equivs[i])
-                {
-                  changed[start++] = 0;
-                  changed[i++] = 1;
-                  while (changed[i])
-                    i++;
-                  while (other_changed[++j])
-                    corresponding = i;
-                }
-            }
-          while (runlength != i - start);
-
-          /* If possible, move the fully-merged run of changes
-             back to a corresponding run in the other file.  */
-
-          while (corresponding < i)
-            {
-              changed[--start] = 1;
-              changed[--i] = 0;
-              while (other_changed[--j])
-                continue;
-            }
-        }
+	  while (i < i_end && !changed[i])
+	    {
+	      while (other_changed[j++])
+		continue;
+	      i++;
+	    }
+
+	  if (i == i_end)
+	    break;
+
+	  start = i;
+
+	  /* Find the end of this run of changes.  */
+
+	  while (changed[++i])
+	    continue;
+	  while (other_changed[j])
+	    j++;
+
+	  do
+	    {
+	      /* Record the length of this run of changes, so that
+		 we can later determine whether the run has grown.  */
+	      runlength = i - start;
+
+	      /* Move the changed region back, so long as the
+		 previous unchanged line matches the last changed one.
+		 This merges with previous changed regions.  */
+
+	      while (start && equivs[start - 1] == equivs[i - 1])
+		{
+		  changed[--start] = 1;
+		  changed[--i] = 0;
+		  while (changed[start - 1])
+		    start--;
+		  while (other_changed[--j])
+		    continue;
+		}
+
+	      /* Set CORRESPONDING to the end of the changed run, at the last
+		 point where it corresponds to a changed run in the other file.
+		 CORRESPONDING == I_END means no such point has been found.  */
+	      corresponding = other_changed[j - 1] ? i : i_end;
+
+	      /* Move the changed region forward, so long as the
+		 first changed line matches the following unchanged one.
+		 This merges with following changed regions.
+		 Do this second, so that if there are no merges,
+		 the changed region is moved forward as far as possible.  */
+
+	      while (i != i_end && equivs[start] == equivs[i])
+		{
+		  changed[start++] = 0;
+		  changed[i++] = 1;
+		  while (changed[i])
+		    i++;
+		  while (other_changed[++j])
+		    corresponding = i;
+		}
+	    }
+	  while (runlength != i - start);
+
+	  /* If possible, move the fully-merged run of changes
+	     back to a corresponding run in the other file.  */
+
+	  while (corresponding < i)
+	    {
+	      changed[--start] = 1;
+	      changed[--i] = 0;
+	      while (other_changed[--j])
+		continue;
+	    }
+	}
     }
 }
 
@@ -362,7 +362,7 @@ shift_boundaries (struct file_data filev
 
 static struct change *
 add_change (lin line0, lin line1, lin deleted, lin inserted,
-            struct change *old)
+	    struct change *old)
 {
   struct change *new = xmalloc (sizeof *new);
 
@@ -393,16 +393,16 @@ build_reverse_script (struct file_data c
   while (i0 < len0 || i1 < len1)
     {
       if (changed0[i0] | changed1[i1])
-        {
-          lin line0 = i0, line1 = i1;
+	{
+	  lin line0 = i0, line1 = i1;
 
-          /* Find # lines changed here in each file.  */
-          while (changed0[i0]) ++i0;
-          while (changed1[i1]) ++i1;
-
-          /* Record this change.  */
-          script = add_change (line0, line1, i0 - line0, i1 - line1, script);
-        }
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0]) ++i0;
+	  while (changed1[i1]) ++i1;
+
+	  /* Record this change.  */
+	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
+	}
 
       /* We have reached lines in the two files that match each other.  */
       i0++, i1++;
@@ -427,16 +427,16 @@ build_script (struct file_data const fil
   while (i0 >= 0 || i1 >= 0)
     {
       if (changed0[i0 - 1] | changed1[i1 - 1])
-        {
-          lin line0 = i0, line1 = i1;
+	{
+	  lin line0 = i0, line1 = i1;
 
-          /* Find # lines changed here in each file.  */
-          while (changed0[i0 - 1]) --i0;
-          while (changed1[i1 - 1]) --i1;
-
-          /* Record this change.  */
-          script = add_change (i0, i1, line0 - i0, line1 - i1, script);
-        }
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0 - 1]) --i0;
+	  while (changed1[i1 - 1]) --i1;
+
+	  /* Record this change.  */
+	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
+	}
 
       /* We have reached lines in the two files that match each other.  */
       i0--, i1--;
@@ -445,16 +445,26 @@ build_script (struct file_data const fil
   return script;
 }
 
-/* If CHANGES, briefly report that two files differed.  */
-static void
+/* If CHANGES, briefly report that two files differed.
+   Return 2 if trouble, CHANGES otherwise.  */
+static int
 briefly_report (int changes, struct file_data const filevec[])
 {
   if (changes)
-    message ((brief
-              ? _("Files %s and %s differ\n")
-              : _("Binary files %s and %s differ\n")),
-             file_label[0] ? file_label[0] : filevec[0].name,
-             file_label[1] ? file_label[1] : filevec[1].name);
+    {
+      char const *label0 = file_label[0] ? file_label[0] : filevec[0].name;
+      char const *label1 = file_label[1] ? file_label[1] : filevec[1].name;
+
+      if (brief)
+	message ("Files %s and %s differ\n", label0, label1);
+      else
+	{
+	  message ("Binary files %s and %s differ\n", label0, label1);
+	  changes = 2;
+	}
+    }
+
+  return changes;
 }
 
 /* Report the differences of two files.  */
@@ -477,58 +487,56 @@ diff_2_files (struct comparison *cmp)
     {
       /* Files with different lengths must be different.  */
       if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
-          && 0 < cmp->file[0].stat.st_size
-          && 0 < cmp->file[1].stat.st_size
-          && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
-          && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
-        changes = 1;
+	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
+	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
+	changes = 1;
 
       /* Standard input equals itself.  */
       else if (cmp->file[0].desc == cmp->file[1].desc)
-        changes = 0;
+	changes = 0;
 
       else
-        /* Scan both files, a buffer at a time, looking for a difference.  */
-        {
-          /* Allocate same-sized buffers for both files.  */
-          size_t lcm_max = PTRDIFF_MAX - 1;
-          size_t buffer_size =
-            buffer_lcm (sizeof (word),
-                        buffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),
-                                    STAT_BLOCKSIZE (cmp->file[1].stat),
-                                    lcm_max),
-                        lcm_max);
-          for (f = 0; f < 2; f++)
-            cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);
-
-          for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)
-            {
-              /* Read a buffer's worth from both files.  */
-              for (f = 0; f < 2; f++)
-                if (0 <= cmp->file[f].desc)
-                  file_block_read (&cmp->file[f],
-                                   buffer_size - cmp->file[f].buffered);
-
-              /* If the buffers differ, the files differ.  */
-              if (cmp->file[0].buffered != cmp->file[1].buffered
-                  || memcmp (cmp->file[0].buffer,
-                             cmp->file[1].buffer,
-                             cmp->file[0].buffered))
-                {
-                  changes = 1;
-                  break;
-                }
-
-              /* If we reach end of file, the files are the same.  */
-              if (cmp->file[0].buffered != buffer_size)
-                {
-                  changes = 0;
-                  break;
-                }
-            }
-        }
+	/* Scan both files, a buffer at a time, looking for a difference.  */
+	{
+	  /* Allocate same-sized buffers for both files.  */
+	  size_t lcm_max = PTRDIFF_MAX - 1;
+	  size_t buffer_size =
+	    buffer_lcm (sizeof (word),
+			buffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),
+				    STAT_BLOCKSIZE (cmp->file[1].stat),
+				    lcm_max),
+			lcm_max);
+	  for (f = 0; f < 2; f++)
+	    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);
+
+	  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)
+	    {
+	      /* Read a buffer's worth from both files.  */
+	      for (f = 0; f < 2; f++)
+		if (0 <= cmp->file[f].desc)
+		  file_block_read (&cmp->file[f],
+				   buffer_size - cmp->file[f].buffered);
+
+	      /* If the buffers differ, the files differ.  */
+	      if (cmp->file[0].buffered != cmp->file[1].buffered
+		  || memcmp (cmp->file[0].buffer,
+			     cmp->file[1].buffer,
+			     cmp->file[0].buffered))
+		{
+		  changes = 1;
+		  break;
+		}
+
+	      /* If we reach end of file, the files are the same.  */
+	      if (cmp->file[0].buffered != buffer_size)
+		{
+		  changes = 0;
+		  break;
+		}
+	    }
+	}
 
-      briefly_report (changes, cmp->file);
+      changes = briefly_report (changes, cmp->file);
     }
   else
     {
@@ -537,9 +545,9 @@ diff_2_files (struct comparison *cmp)
       lin too_expensive;
 
       /* Allocate vectors for the results of comparison:
-         a flag for each line of each file, saying whether that line
-         is an insertion or deletion.
-         Allocate an extra element, always 0, at each end of each vector.  */
+	 a flag for each line of each file, saying whether that line
+	 is an insertion or deletion.
+	 Allocate an extra element, always 0, at each end of each vector.  */
 
       size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;
       char *flag_space = zalloc (s);
@@ -547,18 +555,18 @@ diff_2_files (struct comparison *cmp)
       cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;
 
       /* Some lines are obviously insertions or deletions
-         because they don't match anything.  Detect them now, and
-         avoid even thinking about them in the main comparison algorithm.  */
+	 because they don't match anything.  Detect them now, and
+	 avoid even thinking about them in the main comparison algorithm.  */
 
       discard_confusing_lines (cmp->file);
 
       /* Now do the main comparison algorithm, considering just the
-         undiscarded lines.  */
+	 undiscarded lines.  */
 
       ctxt.xvec = cmp->file[0].undiscarded;
       ctxt.yvec = cmp->file[1].undiscarded;
       diags = (cmp->file[0].nondiscarded_lines
-               + cmp->file[1].nondiscarded_lines + 3);
+	       + cmp->file[1].nondiscarded_lines + 3);
       ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));
       ctxt.bdiag = ctxt.fdiag + diags;
       ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1;
@@ -566,146 +574,145 @@ diff_2_files (struct comparison *cmp)
 
       ctxt.heuristic = speed_large_files;
 
-      /* Set TOO_EXPENSIVE to be the approximate square root of the
-         input size, bounded below by 4096.  4096 seems to be good for
-         circa-2016 CPUs; see Bug#16848 and Bug#24715.  */
+      /* Set TOO_EXPENSIVE to be approximate square root of input size,
+	 bounded below by 256.  */
       too_expensive = 1;
       for (;  diags != 0;  diags >>= 2)
-        too_expensive <<= 1;
-      ctxt.too_expensive = MAX (4096, too_expensive);
+	too_expensive <<= 1;
+      ctxt.too_expensive = MAX (256, too_expensive);
 
       files[0] = cmp->file[0];
       files[1] = cmp->file[1];
 
       compareseq (0, cmp->file[0].nondiscarded_lines,
-                  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);
+		  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);
 
       free (ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1));
 
       /* Modify the results slightly to make them prettier
-         in cases where that can validly be done.  */
+	 in cases where that can validly be done.  */
 
       shift_boundaries (cmp->file);
 
       /* Get the results of comparison in the form of a chain
-         of 'struct change's -- an edit script.  */
+	 of `struct change's -- an edit script.  */
 
       if (output_style == OUTPUT_ED)
-        script = build_reverse_script (cmp->file);
+	script = build_reverse_script (cmp->file);
       else
-        script = build_script (cmp->file);
+	script = build_script (cmp->file);
 
       /* Set CHANGES if we had any diffs.
-         If some changes are ignored, we must scan the script to decide.  */
+	 If some changes are ignored, we must scan the script to decide.  */
       if (ignore_blank_lines || ignore_regexp.fastmap)
-        {
-          struct change *next = script;
-          changes = 0;
-
-          while (next && changes == 0)
-            {
-              struct change *this, *end;
-              lin first0, last0, first1, last1;
-
-              /* Find a set of changes that belong together.  */
-              this = next;
-              end = find_change (next);
-
-              /* Disconnect them from the rest of the changes, making them
-                 a hunk, and remember the rest for next iteration.  */
-              next = end->link;
-              end->link = 0;
-
-              /* Determine whether this hunk is really a difference.  */
-              if (analyze_hunk (this, &first0, &last0, &first1, &last1))
-                changes = 1;
-
-              /* Reconnect the script so it will all be freed properly.  */
-              end->link = next;
-            }
-        }
+	{
+	  struct change *next = script;
+	  changes = 0;
+
+	  while (next && changes == 0)
+	    {
+	      struct change *this, *end;
+	      lin first0, last0, first1, last1;
+
+	      /* Find a set of changes that belong together.  */
+	      this = next;
+	      end = find_change (next);
+
+	      /* Disconnect them from the rest of the changes, making them
+		 a hunk, and remember the rest for next iteration.  */
+	      next = end->link;
+	      end->link = 0;
+
+	      /* Determine whether this hunk is really a difference.  */
+	      if (analyze_hunk (this, &first0, &last0, &first1, &last1))
+		changes = 1;
+
+	      /* Reconnect the script so it will all be freed properly.  */
+	      end->link = next;
+	    }
+	}
       else
-        changes = (script != 0);
+	changes = (script != 0);
 
       if (brief)
-        briefly_report (changes, cmp->file);
+	changes = briefly_report (changes, cmp->file);
       else
-        {
-          if (changes || !no_diff_means_no_output)
-            {
-              /* Record info for starting up output,
-                 to be used if and when we have some output to print.  */
-              setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,
-                            file_label[1] ? file_label[1] : cmp->file[1].name,
-                            cmp->parent != 0);
-
-              switch (output_style)
-                {
-                case OUTPUT_CONTEXT:
-                  print_context_script (script, false);
-                  break;
-
-                case OUTPUT_UNIFIED:
-                  print_context_script (script, true);
-                  break;
-
-                case OUTPUT_ED:
-                  print_ed_script (script);
-                  break;
-
-                case OUTPUT_FORWARD_ED:
-                  pr_forward_ed_script (script);
-                  break;
-
-                case OUTPUT_RCS:
-                  print_rcs_script (script);
-                  break;
-
-                case OUTPUT_NORMAL:
-                  print_normal_script (script);
-                  break;
-
-                case OUTPUT_IFDEF:
-                  print_ifdef_script (script);
-                  break;
-
-                case OUTPUT_SDIFF:
-                  print_sdiff_script (script);
-                  break;
-
-                default:
-                  abort ();
-                }
-
-              finish_output ();
-            }
-        }
+	{
+	  if (changes || !no_diff_means_no_output)
+	    {
+	      /* Record info for starting up output,
+		 to be used if and when we have some output to print.  */
+	      setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,
+			    file_label[1] ? file_label[1] : cmp->file[1].name,
+			    cmp->parent != 0);
+
+	      switch (output_style)
+		{
+		case OUTPUT_CONTEXT:
+		  print_context_script (script, false);
+		  break;
+
+		case OUTPUT_UNIFIED:
+		  print_context_script (script, true);
+		  break;
+
+		case OUTPUT_ED:
+		  print_ed_script (script);
+		  break;
+
+		case OUTPUT_FORWARD_ED:
+		  pr_forward_ed_script (script);
+		  break;
+
+		case OUTPUT_RCS:
+		  print_rcs_script (script);
+		  break;
+
+		case OUTPUT_NORMAL:
+		  print_normal_script (script);
+		  break;
+
+		case OUTPUT_IFDEF:
+		  print_ifdef_script (script);
+		  break;
+
+		case OUTPUT_SDIFF:
+		  print_sdiff_script (script);
+		  break;
+
+		default:
+		  abort ();
+		}
+
+	      finish_output ();
+	    }
+	}
 
       free (cmp->file[0].undiscarded);
 
       free (flag_space);
 
       for (f = 0; f < 2; f++)
-        {
-          free (cmp->file[f].equivs);
-          free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);
-        }
+	{
+	  free (cmp->file[f].equivs);
+	  free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);
+	}
 
       for (e = script; e; e = p)
-        {
-          p = e->link;
-          free (e);
-        }
+	{
+	  p = e->link;
+	  free (e);
+	}
 
       if (! ROBUST_OUTPUT_STYLE (output_style))
-        for (f = 0; f < 2; ++f)
-          if (cmp->file[f].missing_newline)
-            {
-              error (0, 0, "%s: %s\n",
-                     file_label[f] ? file_label[f] : cmp->file[f].name,
-                     _("No newline at end of file"));
-              changes = 2;
-            }
+	for (f = 0; f < 2; ++f)
+	  if (cmp->file[f].missing_newline)
+	    {
+	      error (0, 0, "%s: %s\n",
+		     file_label[f] ? file_label[f] : cmp->file[f].name,
+		     _("No newline at end of file"));
+	      changes = 2;
+	    }
     }
 
   if (cmp->file[0].buffer != cmp->file[1].buffer)
diff -pru diffutils-3.0/cmp.c diffutils-3.0-patch/cmp.c
--- diffutils-3.0/cmp.c	2020-05-30 16:24:16.368947000 -0700
+++ diffutils-3.0-patch/cmp.c	2020-05-30 15:52:03.049080000 -0700
@@ -1,7 +1,7 @@
-/* GNU cmp - compare two files byte by byte
+/* cmp - compare two files byte by byte
 
-   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
-   2015-2020 Free Software Foundation, Inc.
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -23,7 +23,6 @@
 
 #include <c-stack.h>
 #include <cmpbuf.h>
-#include "die.h"
 #include <error.h>
 #include <exitfail.h>
 #include <file-type.h>
@@ -34,11 +33,10 @@
 #include <unlocked-io.h>
 #include <version-etc.h>
 #include <xalloc.h>
-#include <binary-io.h>
-#include <xstdopen.h>
+#include <xfreopen.h>
 #include <xstrtol.h>
 
-/* The official name of this program (e.g., no 'g' prefix).  */
+/* The official name of this program (e.g., no `g' prefix).  */
 #define PROGRAM_NAME "cmp"
 
 #define AUTHORS \
@@ -53,8 +51,8 @@
 
 static int cmp (void);
 static off_t file_position (int);
-static size_t block_compare (word const *, word const *) _GL_ATTRIBUTE_PURE;
-static size_t count_newlines (char *, size_t);
+static size_t block_compare (word const *, word const *);
+static size_t block_compare_and_count (word const *, word const *, off_t *);
 static void sprintc (char *, unsigned char);
 
 /* Filenames of the compared files.  */
@@ -75,8 +73,8 @@ static size_t buf_size;
 /* Initial prefix to ignore for each file.  */
 static off_t ignore_initial[2];
 
-/* Number of bytes to compare, or -1 if there is no limit.  */
-static intmax_t bytes = -1;
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
 
 /* Output format.  */
 static enum comparison_type
@@ -116,8 +114,9 @@ try_help (char const *reason_msgid, char
 {
   if (reason_msgid)
     error (0, 0, _(reason_msgid), operand);
-  die (EXIT_TROUBLE, 0,
-         _("Try '%s --help' for more information."), program_name);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
 }
 
 static char const valid_suffixes[] = "kKMGTPEZY0";
@@ -129,12 +128,12 @@ static char const valid_suffixes[] = "kK
 static void
 specify_ignore_initial (int f, char **argptr, char delimiter)
 {
-  intmax_t val;
+  uintmax_t val;
   char const *arg = *argptr;
-  strtol_error e = xstrtoimax (arg, argptr, 0, &val, valid_suffixes);
-  if (! ((e == LONGINT_OK
-          || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
-         && 0 <= val && val <= TYPE_MAXIMUM (off_t)))
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
     try_help ("invalid --ignore-initial value '%s'", arg);
   if (ignore_initial[f] < val)
     ignore_initial[f] = val;
@@ -153,21 +152,21 @@ static void
 check_stdout (void)
 {
   if (ferror (stdout))
-    die (EXIT_TROUBLE, 0, "%s", _("write failed"));
+    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
   else if (fclose (stdout) != 0)
-    die (EXIT_TROUBLE, errno, "%s", _("standard output"));
+    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
 }
 
 static char const * const option_help_msgid[] = {
-  N_("-b, --print-bytes          print differing bytes"),
-  N_("-i, --ignore-initial=SKIP         skip first SKIP bytes of both inputs"),
-  N_("-i, --ignore-initial=SKIP1:SKIP2  skip first SKIP1 bytes of FILE1 and\n"
-     "                                      first SKIP2 bytes of FILE2"),
-  N_("-l, --verbose              output byte numbers and differing byte values"),
-  N_("-n, --bytes=LIMIT          compare at most LIMIT bytes"),
-  N_("-s, --quiet, --silent      suppress all normal output"),
-  N_("    --help                 display this help and exit"),
-  N_("-v, --version              output version information and exit"),
+  N_("-b  --print-bytes  Print differing bytes."),
+  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
+  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
+  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
+  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
+  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
+  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
   0
 };
 
@@ -177,30 +176,24 @@ usage (void)
   char const * const *p;
 
   printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
-          program_name);
-  printf ("%s\n", _("Compare two files byte by byte."));
-  printf ("\n%s\n\n",
-_("The optional SKIP1 and SKIP2 specify the number of bytes to skip\n"
-  "at the beginning of each file (zero by default)."));
-
-  fputs (_("\
-Mandatory arguments to long options are mandatory for short options too.\n\
-"), stdout);
+	  program_name);
+  printf ("%s\n\n", _("Compare two files byte by byte."));
   for (p = option_help_msgid;  *p;  p++)
     printf ("  %s\n", _(*p));
-  printf ("\n%s\n\n%s\n%s\n",
-          _("SKIP values may be followed by the following multiplicative suffixes:\n\
+  printf ("\n%s\n%s\n\n%s\n%s\n",
+	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
 kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
 GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
-          _("If a FILE is '-' or missing, read standard input."),
-          _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+	  _("If a FILE is '-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
   emit_bug_reporting_address ();
 }
 
 int
 main (int argc, char **argv)
 {
-  int c, exit_status;
+  int c, f, exit_status;
   size_t words_per_buffer;
 
   exit_failure = EXIT_TROUBLE;
@@ -210,59 +203,57 @@ main (int argc, char **argv)
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
   c_stack_action (0);
-  xstdopen ();
 
   /* Parse command line options.  */
 
   while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
-         != -1)
+	 != -1)
     switch (c)
       {
       case 'b':
       case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
-        opt_print_bytes = true;
-        break;
+	opt_print_bytes = true;
+	break;
 
       case 'i':
-        specify_ignore_initial (0, &optarg, ':');
-        if (*optarg++ == ':')
-          specify_ignore_initial (1, &optarg, 0);
-        else if (ignore_initial[1] < ignore_initial[0])
-          ignore_initial[1] = ignore_initial[0];
-        break;
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
 
       case 'l':
-        specify_comparison_type (type_all_diffs);
-        break;
+	specify_comparison_type (type_all_diffs);
+	break;
 
       case 'n':
-        {
-          intmax_t n;
-          if (xstrtoimax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK
-              || n < 0)
-            try_help ("invalid --bytes value '%s'", optarg);
-          if (! (0 <= bytes && bytes < n))
-            bytes = n;
-        }
-        break;
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value '%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
 
       case 's':
-        specify_comparison_type (type_status);
-        break;
+	specify_comparison_type (type_status);
+	break;
 
       case 'v':
-        version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
-                     AUTHORS, (char *) NULL);
-        check_stdout ();
-        return EXIT_SUCCESS;
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
 
       case HELP_OPTION:
-        usage ();
-        check_stdout ();
-        return EXIT_SUCCESS;
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
 
       default:
-        try_help (0, 0);
+	try_help (0, 0);
       }
 
   if (optind == argc)
@@ -271,7 +262,7 @@ main (int argc, char **argv)
   file[0] = argv[optind++];
   file[1] = optind < argc ? argv[optind++] : "-";
 
-  for (int f = 0; f < 2 && optind < argc; f++)
+  for (f = 0; f < 2 && optind < argc; f++)
     {
       char *arg = argv[optind++];
       specify_ignore_initial (f, &arg, 0);
@@ -280,30 +271,34 @@ main (int argc, char **argv)
   if (optind < argc)
     try_help ("extra operand '%s'", argv[optind]);
 
-  for (int f = 0; f < 2; f++)
+  for (f = 0; f < 2; f++)
     {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
       /* Two files with the same name and offset are identical.
-         But wait until we open the file once, for proper diagnostics.  */
+	 But wait until we open the file once, for proper diagnostics.  */
       if (f && ignore_initial[0] == ignore_initial[1]
-          && file_name_cmp (file[0], file[1]) == 0)
-        return EXIT_SUCCESS;
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
 
-      if (STREQ (file[f], "-"))
-        {
-          file_desc[f] = STDIN_FILENO;
-          if (O_BINARY && ! isatty (STDIN_FILENO))
-            set_binary_mode (STDIN_FILENO, O_BINARY);
-        }
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    xfreopen (NULL, "rb", stdin);
+	}
       else
-        file_desc[f] = open (file[f], O_RDONLY | O_BINARY, 0);
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
 
-      if (file_desc[f] < 0 || fstat (file_desc[f], stat_buf + f) != 0)
-        {
-          if (file_desc[f] < 0 && comparison_type == type_status)
-            exit (EXIT_TROUBLE);
-          else
-            die (EXIT_TROUBLE, errno, "%s", file[f]);
-        }
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
     }
 
   /* If the files are links to the same inode and have the same file position,
@@ -322,9 +317,9 @@ main (int argc, char **argv)
       struct stat outstat, nullstat;
 
       if (fstat (STDOUT_FILENO, &outstat) == 0
-          && stat (NULL_DEVICE, &nullstat) == 0
-          && 0 < same_file (&outstat, &nullstat))
-        comparison_type = type_no_stdout;
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
     }
 
   /* If only a return code is needed,
@@ -339,18 +334,18 @@ main (int argc, char **argv)
       off_t s0 = stat_buf[0].st_size - file_position (0);
       off_t s1 = stat_buf[1].st_size - file_position (1);
       if (s0 < 0)
-        s0 = 0;
+	s0 = 0;
       if (s1 < 0)
-        s1 = 0;
-      if (s0 != s1 && (bytes < 0 || MIN (s0, s1) < bytes))
-        exit (EXIT_FAILURE);
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
     }
 
   /* Get the optimal block size of the files.  */
 
   buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
-                         STAT_BLOCKSIZE (stat_buf[1]),
-                         PTRDIFF_MAX - sizeof (word));
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
 
   /* Allocate word-aligned buffers, with space for sentinels at the end.  */
 
@@ -360,9 +355,9 @@ main (int argc, char **argv)
 
   exit_status = cmp ();
 
-  for (int f = 0; f < 2; f++)
+  for (f = 0; f < 2; f++)
     if (close (file_desc[f]) != 0)
-      die (EXIT_TROUBLE, errno, "%s", file[f]);
+      error (EXIT_TROUBLE, errno, "%s", file[f]);
   if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
     check_stdout ();
   exit (exit_status);
@@ -377,10 +372,9 @@ main (int argc, char **argv)
 static int
 cmp (void)
 {
-  bool at_line_start = true;
   off_t line_number = 1;	/* Line number (1...) of difference. */
   off_t byte_number = 1;	/* Byte number (1...) of difference. */
-  intmax_t remaining = bytes;	/* Remaining bytes to compare, or -1.  */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
   size_t read0, read1;		/* Number of bytes read from each file. */
   size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
   size_t smaller;		/* The lesser of 'read0' and 'read1'. */
@@ -394,214 +388,227 @@ cmp (void)
 
   if (comparison_type == type_all_diffs)
     {
-      off_t byte_number_max = (0 <= bytes && bytes <= TYPE_MAXIMUM (off_t)
-			       ? bytes : TYPE_MAXIMUM (off_t));
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
 
       for (f = 0; f < 2; f++)
-        if (S_ISREG (stat_buf[f].st_mode))
-          {
-            off_t file_bytes = stat_buf[f].st_size - file_position (f);
-            if (file_bytes < byte_number_max)
-              byte_number_max = file_bytes;
-          }
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
 
       for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
-        continue;
+	continue;
     }
 
   for (f = 0; f < 2; f++)
     {
       off_t ig = ignore_initial[f];
       if (ig && file_position (f) == -1)
-        {
-          /* lseek failed; read and discard the ignored initial prefix.  */
-          do
-            {
-              size_t bytes_to_read = MIN (ig, buf_size);
-              size_t r = block_read (file_desc[f], buf0, bytes_to_read);
-              if (r != bytes_to_read)
-                {
-                  if (r == SIZE_MAX)
-                    die (EXIT_TROUBLE, errno, "%s", file[f]);
-                  break;
-                }
-              ig -= r;
-            }
-          while (ig);
-        }
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
     }
 
   do
     {
       size_t bytes_to_read = buf_size;
 
-      if (0 <= remaining)
-        {
-          if (remaining < bytes_to_read)
-            bytes_to_read = remaining;
-          remaining -= bytes_to_read;
-        }
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
 
       read0 = block_read (file_desc[0], buf0, bytes_to_read);
       if (read0 == SIZE_MAX)
-        die (EXIT_TROUBLE, errno, "%s", file[0]);
+	error (EXIT_TROUBLE, errno, "%s", file[0]);
       read1 = block_read (file_desc[1], buf1, bytes_to_read);
       if (read1 == SIZE_MAX)
-        die (EXIT_TROUBLE, errno, "%s", file[1]);
+	error (EXIT_TROUBLE, errno, "%s", file[1]);
 
-      smaller = MIN (read0, read1);
+      /* Insert sentinels for the block compare.  */
 
-      /* Optimize the common case where the buffers are the same.  */
-      if (memcmp (buf0, buf1, smaller) == 0)
-        first_diff = smaller;
-      else
-        {
-          /* Insert sentinels for the block compare.  */
-          buf0[read0] = ~buf1[read0];
-          buf1[read1] = ~buf0[read1];
+      buf0[read0] = ~buf1[read0];
+      buf1[read1] = ~buf0[read1];
 
-          first_diff = block_compare (buffer0, buffer1);
-        }
+      /* If the line number should be written for differing files,
+	 compare the blocks and count the number of newlines
+	 simultaneously.  */
+      first_diff = (comparison_type == type_first_diff
+		    ? block_compare_and_count (buffer0, buffer1, &line_number)
+		    : block_compare (buffer0, buffer1));
 
       byte_number += first_diff;
-      if (comparison_type == type_first_diff && first_diff != 0)
-        {
-          line_number += count_newlines (buf0, first_diff);
-          at_line_start = buf0[first_diff - 1] == '\n';
-        }
+      smaller = MIN (read0, read1);
 
       if (first_diff < smaller)
-        {
-          switch (comparison_type)
-            {
-            case type_first_diff:
-              {
-                char byte_buf[INT_BUFSIZE_BOUND (off_t)];
-                char line_buf[INT_BUFSIZE_BOUND (off_t)];
-                char const *byte_num = offtostr (byte_number, byte_buf);
-                char const *line_num = offtostr (line_number, line_buf);
-                if (!opt_print_bytes)
-                  {
-                    /* See POSIX for this format.  This message is
-                       used only in the POSIX locale, so it need not
-                       be translated.  */
-                    static char const char_message[] =
-                      "%s %s differ: char %s, line %s\n";
-
-                    /* The POSIX rationale recommends using the word
-                       "byte" outside the POSIX locale.  Some gettext
-                       implementations translate even in the POSIX
-                       locale if certain other environment variables
-                       are set, so use "byte" if a translation is
-                       available, or if outside the POSIX locale.  */
-                    static char const byte_msgid[] =
-                      N_("%s %s differ: byte %s, line %s\n");
-                    char const *byte_message = _(byte_msgid);
-                    bool use_byte_message = (byte_message != byte_msgid
-                                             || hard_locale_LC_MESSAGES);
-
-                    printf (use_byte_message ? byte_message : char_message,
-                            file[0], file[1], byte_num, line_num);
-                  }
-                else
-                  {
-                    unsigned char c0 = buf0[first_diff];
-                    unsigned char c1 = buf1[first_diff];
-                    char s0[5];
-                    char s1[5];
-                    sprintc (s0, c0);
-                    sprintc (s1, c1);
-                    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
-                            file[0], file[1], byte_num, line_num,
-                            c0, s0, c1, s1);
-                  }
-              }
-              FALLTHROUGH;
-            case type_status:
-              return EXIT_FAILURE;
-
-            case type_all_diffs:
-              do
-                {
-                  unsigned char c0 = buf0[first_diff];
-                  unsigned char c1 = buf1[first_diff];
-                  if (c0 != c1)
-                    {
-                      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
-                      char const *byte_num = offtostr (byte_number, byte_buf);
-                      if (!opt_print_bytes)
-                        {
-                          /* See POSIX for this format.  */
-                          printf ("%*s %3o %3o\n",
-                                  offset_width, byte_num, c0, c1);
-                        }
-                      else
-                        {
-                          char s0[5];
-                          char s1[5];
-                          sprintc (s0, c0);
-                          sprintc (s1, c1);
-                          printf ("%*s %3o %-4s %3o %s\n",
-                                  offset_width, byte_num, c0, s0, c1, s1);
-                        }
-                    }
-                  byte_number++;
-                  first_diff++;
-                }
-              while (first_diff < smaller);
-              differing = -1;
-              break;
-
-            case type_no_stdout:
-              differing = 1;
-              break;
-            }
-        }
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX 1003.1-2001 for this format.  This
+		       message is used only in the POSIX locale, so it
+		       need not be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		}
+	      }
+	      /* Fall through.  */
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX 1003.1-2001 for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
 
       if (read0 != read1)
-        {
-          if (differing <= 0 && comparison_type != type_status)
-            {
-              char const *shorter_file = file[read1 < read0];
-
-              /* POSIX says that each of these format strings must be
-                 "cmp: EOF on %s", optionally followed by a blank and
-                 extra text sans newline, then terminated by "\n".  */
-              if (byte_number == 1)
-                fprintf (stderr, _("cmp: EOF on %s which is empty\n"),
-                         shorter_file);
-              else
-                {
-                  char byte_buf[INT_BUFSIZE_BOUND (off_t)];
-                  char const *byte_num = offtostr (byte_number - 1, byte_buf);
-
-                  if (comparison_type == type_first_diff)
-                    {
-                      char line_buf[INT_BUFSIZE_BOUND (off_t)];
-                      char const *line_num
-                        = offtostr (line_number - at_line_start, line_buf);
-                      fprintf (stderr,
-                               (at_line_start
-                                ? _("cmp: EOF on %s after byte %s, line %s\n")
-                                : _("cmp: EOF on %s after byte %s,"
-                                    " in line %s\n")),
-                               shorter_file, byte_num, line_num);
-                    }
-                  else
-                    fprintf (stderr,
-                             _("cmp: EOF on %s after byte %s\n"),
-                             shorter_file, byte_num);
-                }
-            }
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+	    }
 
-          return EXIT_FAILURE;
-        }
+	  return EXIT_FAILURE;
+	}
     }
   while (differing <= 0 && read0 == buf_size);
 
   return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
 }
 
+/* Compare two blocks of memory P0 and P1 until they differ,
+   and count the number of '\n' occurrences in the common
+   part of P0 and P1.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.
+   Increment *COUNT by the count of '\n' occurrences.  */
+
+static size_t
+block_compare_and_count (word const *p0, word const *p1, off_t *count)
+{
+  word l;		/* One word from first buffer. */
+  word const *l0, *l1;	/* Pointers into each buffer. */
+  char const *c0, *c1;	/* Pointers for finding exact address. */
+  size_t cnt = 0;	/* Number of '\n' occurrences. */
+  word nnnn;		/* Newline, sizeof (word) times.  */
+  int i;
+
+  nnnn = 0;
+  for (i = 0; i < sizeof nnnn; i++)
+    nnnn = (nnnn << CHAR_BIT) | '\n';
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
+    {
+      l ^= nnnn;
+      for (i = 0; i < sizeof l; i++)
+	{
+	  unsigned char uc = l;
+	  cnt += ! uc;
+	  l >>= CHAR_BIT;
+	}
+    }
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    cnt += *c0 == '\n';
+
+  *count += cnt;
+  return c0 - (char const *) p0;
+}
+
 /* Compare two blocks of memory P0 and P1 until they differ.
    If the blocks are not guaranteed to be different, put sentinels at the ends
    of the blocks before calling this function.
@@ -630,23 +637,6 @@ block_compare (word const *p0, word cons
   return c0 - (char const *) p0;
 }
 
-/* Return the number of newlines in BUF, of size BUFSIZE,
-   where BUF[NBYTES] is available for use as a sentinel.  */
-
-static size_t
-count_newlines (char *buf, size_t bufsize)
-{
-  size_t count = 0;
-  char *p;
-  char *lim = buf + bufsize;
-  char ch = *lim;
-  *lim = '\n';
-  for (p = buf; (p = rawmemchr (p, '\n')) != lim; p++)
-    count++;
-  *lim = ch;
-  return count;
-}
-
 /* Put into BUF the unsigned char C, making unprintable bytes
    visible by quoting like cat -t does.  */
 
@@ -656,21 +646,21 @@ sprintc (char *buf, unsigned char c)
   if (! isprint (c))
     {
       if (c >= 128)
-        {
-          *buf++ = 'M';
-          *buf++ = '-';
-          c -= 128;
-        }
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
       if (c < 32)
-        {
-          *buf++ = '^';
-          c += 64;
-        }
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
       else if (c == 127)
-        {
-          *buf++ = '^';
-          c = '?';
-        }
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
     }
 
   *buf++ = c;
diff -pru diffutils-3.0/context.c diffutils-3.0-patch/context.c
--- diffutils-3.0/context.c	2020-05-30 16:24:16.371943000 -0700
+++ diffutils-3.0-patch/context.c	2020-05-30 15:52:03.052077000 -0700
@@ -1,7 +1,7 @@
 /* Context-format output routines for GNU DIFF.
 
-   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
-   2015-2020 Free Software Foundation, Inc.
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -20,6 +20,7 @@
 
 #include "diff.h"
 #include "c-ctype.h"
+#include <inttostr.h>
 #include <stat-time.h>
 #include <strftime.h>
 
@@ -39,59 +40,55 @@ static lin find_function_last_match;
 
 static void
 print_context_label (char const *mark,
-                     struct file_data *inf,
-                     char const *name,
-                     char const *label)
+		     struct file_data *inf,
+		     char const *label)
 {
-  set_color_context (HEADER_CONTEXT);
   if (label)
-    fprintf (outfile, "%s %s", mark, label);
+    fprintf (outfile, "%s %s\n", mark, label);
   else
     {
       char buf[MAX (INT_STRLEN_BOUND (int) + 32,
-                    INT_STRLEN_BOUND (time_t) + 11)];
+		    INT_STRLEN_BOUND (time_t) + 11)];
       struct tm const *tm = localtime (&inf->stat.st_mtime);
       int nsec = get_stat_mtime_ns (&inf->stat);
       if (! (tm && nstrftime (buf, sizeof buf, time_format, tm, 0, nsec)))
-        {
-          verify (TYPE_IS_INTEGER (time_t));
-          if (LONG_MIN <= TYPE_MINIMUM (time_t)
-              && TYPE_MAXIMUM (time_t) <= LONG_MAX)
-            {
-              long int sec = inf->stat.st_mtime;
-              sprintf (buf, "%ld.%.9d", sec, nsec);
-            }
-          else if (TYPE_MAXIMUM (time_t) <= INTMAX_MAX)
-            {
-              intmax_t sec = inf->stat.st_mtime;
-              sprintf (buf, "%"PRIdMAX".%.9d", sec, nsec);
-            }
-          else
-            {
-              uintmax_t sec = inf->stat.st_mtime;
-              sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
-            }
-        }
-      fprintf (outfile, "%s %s\t%s", mark, name, buf);
+	{
+	  verify (TYPE_IS_INTEGER (time_t));
+	  if (LONG_MIN <= TYPE_MINIMUM (time_t)
+	      && TYPE_MAXIMUM (time_t) <= LONG_MAX)
+	    {
+	      long int sec = inf->stat.st_mtime;
+	      sprintf (buf, "%ld.%.9d", sec, nsec);
+	    }
+	  else if (TYPE_MAXIMUM (time_t) <= INTMAX_MAX)
+	    {
+	      intmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIdMAX".%.9d", sec, nsec);
+	    }
+	  else
+	    {
+	      uintmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
+	    }
+	}
+      fprintf (outfile, "%s %s\t%s\n", mark, inf->name, buf);
     }
-  set_color_context (RESET_CONTEXT);
-  putc ('\n', outfile);
 }
 
 /* Print a header for a context diff, with the file names and dates.  */
 
 void
-print_context_header (struct file_data inf[], char const *const *names, bool unidiff)
+print_context_header (struct file_data inf[], bool unidiff)
 {
   if (unidiff)
     {
-      print_context_label ("---", &inf[0], names[0], file_label[0]);
-      print_context_label ("+++", &inf[1], names[1], file_label[1]);
+      print_context_label ("---", &inf[0], file_label[0]);
+      print_context_label ("+++", &inf[1], file_label[1]);
     }
   else
     {
-      print_context_label ("***", &inf[0], names[0], file_label[0]);
-      print_context_label ("---", &inf[1], names[1], file_label[1]);
+      print_context_label ("***", &inf[0], file_label[0]);
+      print_context_label ("---", &inf[1], file_label[1]);
     }
 }
 
@@ -106,7 +103,7 @@ print_context_script (struct change *scr
     {
       struct change *e;
       for (e = script; e; e = e->link)
-        e->ignore = false;
+	e->ignore = false;
     }
 
   find_function_last_search = - files[0].prefix_lines;
@@ -127,7 +124,7 @@ print_context_script (struct change *scr
 static void
 print_context_number_range (struct file_data const *file, lin a, lin b)
 {
-  printint trans_a, trans_b;
+  long int trans_a, trans_b;
   translate_range (file, a, b, &trans_a, &trans_b);
 
   /* We can have B <= A in the case of a range of no lines.
@@ -140,9 +137,9 @@ print_context_number_range (struct file_
      specification.  */
 
   if (trans_b <= trans_a)
-    fprintf (outfile, "%"pI"d", trans_b);
+    fprintf (outfile, "%ld", trans_b);
   else
-    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b);
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b);
 }
 
 /* Print FUNCTION in a context header.  */
@@ -162,7 +159,7 @@ print_context_function (FILE *out, char
 
 /* Print a portion of an edit script in context format.
    HUNK is the beginning of the portion to be printed.
-   The end is marked by a 'link' that has been nulled out.
+   The end is marked by a `link' that has been nulled out.
 
    Prints out lines from both files, and precedes each
    line with the appropriate flag-character.  */
@@ -208,81 +205,62 @@ pr_context_hunk (struct change *hunk)
   if (function)
     print_context_function (out, function);
 
-  putc ('\n', out);
-  set_color_context (LINE_NUMBER_CONTEXT);
-  fputs ("*** ", out);
+  fputs ("\n*** ", out);
   print_context_number_range (&files[0], first0, last0);
-  fputs (" ****", out);
-  set_color_context (RESET_CONTEXT);
-  putc ('\n', out);
+  fputs (" ****\n", out);
 
   if (changes & OLD)
     {
       struct change *next = hunk;
 
       for (i = first0; i <= last0; i++)
-        {
-          set_color_context (DELETE_CONTEXT);
-
-          /* Skip past changes that apply (in file 0)
-             only to lines before line I.  */
+	{
+	  /* Skip past changes that apply (in file 0)
+	     only to lines before line I.  */
+
+	  while (next && next->line0 + next->deleted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line0 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were inserted here in file 1, this is "changed".
+	       Otherwise it is "deleted".  */
+	    prefix = (next->inserted > 0 ? "!" : "-");
 
-          while (next && next->line0 + next->deleted <= i)
-            next = next->link;
-
-          /* Compute the marking for line I.  */
-
-          prefix = " ";
-          if (next && next->line0 <= i)
-            {
-              /* The change NEXT covers this line.
-                 If lines were inserted here in file 1, this is "changed".
-                 Otherwise it is "deleted".  */
-              prefix = (next->inserted > 0 ? "!" : "-");
-            }
-          print_1_line_nl (prefix, &files[0].linbuf[i], true);
-          set_color_context (RESET_CONTEXT);
-          if (files[0].linbuf[i + 1][-1] == '\n')
-            putc ('\n', out);
-        }
+	  print_1_line (prefix, &files[0].linbuf[i]);
+	}
     }
 
-  set_color_context (LINE_NUMBER_CONTEXT);
   fputs ("--- ", out);
   print_context_number_range (&files[1], first1, last1);
-  fputs (" ----", out);
-  set_color_context (RESET_CONTEXT);
-  putc ('\n', out);
+  fputs (" ----\n", out);
 
   if (changes & NEW)
     {
       struct change *next = hunk;
 
       for (i = first1; i <= last1; i++)
-        {
-          set_color_context (ADD_CONTEXT);
-
-          /* Skip past changes that apply (in file 1)
-             only to lines before line I.  */
-
-          while (next && next->line1 + next->inserted <= i)
-            next = next->link;
+	{
+	  /* Skip past changes that apply (in file 1)
+	     only to lines before line I.  */
+
+	  while (next && next->line1 + next->inserted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line1 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were deleted here in file 0, this is "changed".
+	       Otherwise it is "inserted".  */
+	    prefix = (next->deleted > 0 ? "!" : "+");
 
-          /* Compute the marking for line I.  */
-
-          prefix = " ";
-          if (next && next->line1 <= i)
-            {
-              /* The change NEXT covers this line.
-                 If lines were deleted here in file 0, this is "changed".
-                 Otherwise it is "inserted".  */
-              prefix = (next->deleted > 0 ? "!" : "+");
-            }
-          print_1_line_nl (prefix, &files[1].linbuf[i], true);
-          set_color_context (RESET_CONTEXT);
-          if (files[1].linbuf[i + 1][-1] == '\n')
-            putc ('\n', out);
-        }
+	  print_1_line (prefix, &files[1].linbuf[i]);
+	}
     }
 }
 
@@ -296,7 +274,7 @@ pr_context_hunk (struct change *hunk)
 static void
 print_unidiff_number_range (struct file_data const *file, lin a, lin b)
 {
-  printint trans_a, trans_b;
+  long int trans_a, trans_b;
   translate_range (file, a, b, &trans_a, &trans_b);
 
   /* We can have B < A in the case of a range of no lines.
@@ -304,9 +282,9 @@ print_unidiff_number_range (struct file_
      which is B.  It would be more logical to print A, but
      'patch' expects B in order to detect diffs against empty files.  */
   if (trans_b <= trans_a)
-    fprintf (outfile, trans_b < trans_a ? "%"pI"d,0" : "%"pI"d", trans_b);
+    fprintf (outfile, trans_b < trans_a ? "%ld,0" : "%ld", trans_b);
   else
-    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b - trans_a + 1);
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b - trans_a + 1);
 }
 
 /* Print a portion of an edit script in unidiff format.
@@ -352,13 +330,11 @@ pr_unidiff_hunk (struct change *hunk)
   begin_output ();
   out = outfile;
 
-  set_color_context (LINE_NUMBER_CONTEXT);
   fputs ("@@ -", out);
   print_unidiff_number_range (&files[0], first0, last0);
   fputs (" +", out);
   print_unidiff_number_range (&files[1], first1, last1);
   fputs (" @@", out);
-  set_color_context (RESET_CONTEXT);
 
   if (function)
     print_context_function (out, function);
@@ -375,57 +351,43 @@ pr_unidiff_hunk (struct change *hunk)
       /* If the line isn't a difference, output the context from file 0. */
 
       if (!next || i < next->line0)
-        {
-          char const *const *line = &files[0].linbuf[i++];
-          if (! (suppress_blank_empty && **line == '\n'))
-            putc (initial_tab ? '\t' : ' ', out);
-          print_1_line (NULL, line);
-          j++;
-        }
+	{
+	  char const *const *line = &files[0].linbuf[i++];
+	  if (! (suppress_blank_empty && **line == '\n'))
+	    putc (initial_tab ? '\t' : ' ', out);
+	  print_1_line (NULL, line);
+	  j++;
+	}
       else
-        {
-          /* For each difference, first output the deleted part. */
-
-          k = next->deleted;
-
-          while (k--)
-            {
-              char const * const *line = &files[0].linbuf[i++];
-              set_color_context (DELETE_CONTEXT);
-              putc ('-', out);
-              if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
-                putc ('\t', out);
-              print_1_line_nl (NULL, line, true);
-
-              set_color_context (RESET_CONTEXT);
-
-              if (line[1][-1] == '\n')
-                putc ('\n', out);
-            }
-
-          /* Then output the inserted part. */
-
-          k = next->inserted;
-
-          while (k--)
-            {
-              char const * const *line = &files[1].linbuf[j++];
-              set_color_context (ADD_CONTEXT);
-              putc ('+', out);
-              if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
-                putc ('\t', out);
-              print_1_line_nl (NULL, line, true);
-
-              set_color_context (RESET_CONTEXT);
+	{
+	  /* For each difference, first output the deleted part. */
 
-              if (line[1][-1] == '\n')
-                putc ('\n', out);
-            }
+	  k = next->deleted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[0].linbuf[i++];
+	      putc ('-', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
+
+	  /* Then output the inserted part. */
+
+	  k = next->inserted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[1].linbuf[j++];
+	      putc ('+', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
 
-          /* We're done with this hunk, so on to the next! */
+	  /* We're done with this hunk, so on to the next! */
 
-          next = next->link;
-        }
+	  next = next->link;
+	}
     }
 }
 
@@ -433,18 +395,19 @@ pr_unidiff_hunk (struct change *hunk)
    2*CONTEXT unchanged lines appear, and return a pointer
    to the 'struct change' for the last change before those lines.  */
 
-static struct change * _GL_ATTRIBUTE_PURE
+static struct change *
 find_hunk (struct change *start)
 {
   struct change *prev;
   lin top0, top1;
   lin thresh;
 
-  /* Threshold distance is CONTEXT if the second change is ignorable,
-     2 * CONTEXT + 1 otherwise.  Integer overflow can't happen, due
-     to CONTEXT_LIM.  */
+  /* Threshold distance is 2 * CONTEXT + 1 between two non-ignorable
+     changes, but only CONTEXT if one is ignorable.  Watch out for
+     integer overflow, though.  */
+  lin non_ignorable_threshold =
+    (LIN_MAX - 1) / 2 < context ? LIN_MAX : 2 * context + 1;
   lin ignorable_threshold = context;
-  lin non_ignorable_threshold = 2 * context + 1;
 
   do
     {
@@ -453,17 +416,17 @@ find_hunk (struct change *start)
       top1 = start->line1 + start->inserted;
       prev = start;
       start = start->link;
-      thresh = (start && start->ignore
-                ? ignorable_threshold
-                : non_ignorable_threshold);
+      thresh = (prev->ignore || (start && start->ignore)
+		? ignorable_threshold
+		: non_ignorable_threshold);
       /* It is not supposed to matter which file we check in the end-test.
-         If it would matter, crash.  */
+	 If it would matter, crash.  */
       if (start && start->line0 - top0 != start->line1 - top1)
-        abort ();
+	abort ();
     } while (start
-             /* Keep going if less than THRESH lines
-                elapse before the affected line.  */
-             && start->line0 - top0 < thresh);
+	     /* Keep going if less than THRESH lines
+		elapse before the affected line.  */
+	     && start->line0 - top0 < thresh);
 
   return prev;
 }
@@ -485,7 +448,7 @@ mark_ignorable (struct change *script)
 
       /* Determine whether this change is ignorable.  */
       script->ignore = ! analyze_hunk (script,
-                                       &first0, &last0, &first1, &last1);
+				       &first0, &last0, &first1, &last1);
 
       /* Reconnect the chain as before.  */
       script->link = next;
@@ -516,10 +479,10 @@ find_function (char const * const *linbu
       int len = MIN (linelen, INT_MAX);
 
       if (0 <= re_search (&function_regexp, line, len, 0, len, NULL))
-        {
-          find_function_last_match = i;
-          return line;
-        }
+	{
+	  find_function_last_match = i;
+	  return line;
+	}
     }
   /* If we search back to where we started searching the previous time,
      find the line we found last time.  */
diff -pru diffutils-3.0/diff3.c diffutils-3.0-patch/diff3.c
--- diffutils-3.0/diff3.c	2020-05-30 16:24:16.374940000 -0700
+++ diffutils-3.0-patch/diff3.c	2020-05-30 15:52:03.055075000 -0700
@@ -1,7 +1,8 @@
-/* GNU diff3 - compare three files line by line
 
-   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2013,
-   2015-2020 Free Software Foundation, Inc.
+/* diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -24,17 +25,16 @@
 
 #include <c-stack.h>
 #include <cmpbuf.h>
-#include "die.h"
 #include <error.h>
 #include <exitfail.h>
 #include <file-type.h>
 #include <getopt.h>
+#include <inttostr.h>
 #include <progname.h>
-#include <system-quote.h>
+#include <sh-quote.h>
 #include <version-etc.h>
 #include <xalloc.h>
 #include <xfreopen.h>
-#include <xstdopen.h>
 
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "diff3"
@@ -80,9 +80,6 @@ struct diff_block {
   char **lines[2];		/* The actual lines (may contain nulls) */
   size_t *lengths[2];		/* Line lengths (including newlines, if any) */
   struct diff_block *next;
-#ifdef lint
-  struct diff_block *n2;	/* Used only when freeing.  */
-#endif
 };
 
 /* Three way diff */
@@ -181,7 +178,7 @@ static struct diff3_block *create_diff3_
 static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
 static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
 static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
-static struct diff_block *process_diff (char const *, char const *, struct diff_block **, char **);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
 static void check_stdout (void);
 static void fatal (char const *) __attribute__((noreturn));
 static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
@@ -217,38 +214,6 @@ static struct option const longopts[] =
   {0, 0, 0, 0}
 };
 
-static void
-free_diff_block (struct diff_block *p)
-{
-#ifndef lint
-  (void)p;
-#else
-  while (p)
-    {
-      free (p->lines[0]);
-      free (p->lines[1]);
-      free (p->lengths[0]);
-      free (p->lengths[1]);
-      struct diff_block *next = p->n2;
-      free (p);
-      p = next;
-    }
-#endif
-}
-
-/* Copy each next pointer to n2, since make_3way_diff would clobber the former,
-   yet we will still need something to free these buffers.  */
-static void
-next_to_n2 (struct diff_block *p)
-{
-#ifndef lint
-  (void)p;
-#else
-  while (p)
-    p = p->n2 = p->next;
-#endif
-}
-
 int
 main (int argc, char **argv)
 {
@@ -273,77 +238,74 @@ main (int argc, char **argv)
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
   c_stack_action (0);
-  xstdopen ();
 
   while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
     {
       switch (c)
-        {
-        case 'a':
-          text = true;
-          break;
-        case 'A':
-          show_2nd = true;
-          flagging = true;
-          incompat++;
-          break;
-        case 'x':
-          overlap_only = true;
-          incompat++;
-          break;
-        case '3':
-          simple_only = true;
-          incompat++;
-          break;
-        case 'i':
-          finalwrite = true;
-          break;
-        case 'm':
-          merge = true;
-          break;
-        case 'X':
-          overlap_only = true;
-          FALLTHROUGH;
-        case 'E':
-          flagging = true;
-          FALLTHROUGH;
-        case 'e':
-          incompat++;
-          break;
-        case 'T':
-          initial_tab = true;
-          break;
-        case STRIP_TRAILING_CR_OPTION:
-          strip_trailing_cr = true;
-          break;
-        case 'v':
-          version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
-                       AUTHORS, (char *) NULL);
-          check_stdout ();
-          return EXIT_SUCCESS;
-        case DIFF_PROGRAM_OPTION:
-          diff_program = optarg;
-          break;
-        case HELP_OPTION:
-          usage ();
-          check_stdout ();
-          return EXIT_SUCCESS;
-        case 'L':
-          /* Handle up to three -L options.  */
-          if (tag_count < 3)
-            {
-              tag_strings[tag_count++] = optarg;
-              break;
-            }
-          try_help ("too many file label options", 0);
-        default:
-          try_help (0, 0);
-        }
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  /* Fall through.  */
+	case 'E':
+	  flagging = true;
+	  /* Fall through.  */
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
     }
 
-  /* -AeExX3 without -m implies ed script.  */
-  edscript = incompat & ~(int) merge;
-
+  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
   show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
   flagging |= ~incompat & merge;
 
@@ -355,9 +317,9 @@ main (int argc, char **argv)
   if (argc - optind != 3)
     {
       if (argc - optind < 3)
-        try_help ("missing operand after '%s'", argv[argc - 1]);
+	try_help ("missing operand after '%s'", argv[argc - 1]);
       else
-        try_help ("extra operand '%s'", argv[optind + 3]);
+	try_help ("extra operand '%s'", argv[optind + 3]);
     }
 
   file = &argv[optind];
@@ -386,11 +348,11 @@ main (int argc, char **argv)
   if (STREQ (file[common], "-"))
     {
       /* Sigh.  We've got standard input as the common file.  We can't
-         call diff twice on stdin.  Use the other arg as the common
-         file instead.  */
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
       common = 3 - common;
       if (STREQ (file[0], "-") || STREQ (file[common], "-"))
-        fatal ("'-' specified for more than one input file");
+	fatal ("'-' specified for more than one input file");
     }
 
   mapping[0] = 0;
@@ -401,12 +363,12 @@ main (int argc, char **argv)
     rev_mapping[mapping[i]] = i;
 
   for (i = 0; i < 3; i++)
-    if (! STREQ (file[i], "-"))
+    if (strcmp (file[i], "-") != 0)
       {
-        if (stat (file[i], &statb) < 0)
-          perror_with_exit (file[i]);
-        else if (S_ISDIR (statb.st_mode))
-          die (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
       }
 
 #ifdef SIGCHLD
@@ -417,31 +379,22 @@ main (int argc, char **argv)
   /* Invoke diff twice on two pairs of input files, combine the two
      diffs, and output them.  */
 
-  char *b0, *b1;
   commonname = file[rev_mapping[FILEC]];
-  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block, &b1);
-  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block, &b0);
-
-  next_to_n2 (thread0);
-  next_to_n2 (thread1);
-
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
   diff3 = make_3way_diff (thread0, thread1);
-
-  free_diff_block (thread0);
-  free_diff_block (thread1);
-
   if (edscript)
     conflicts_found
       = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
-                               tag_strings[0], tag_strings[1], tag_strings[2]);
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
   else if (merge)
     {
       xfreopen (file[rev_mapping[FILE0]], "r", stdin);
       conflicts_found
-        = output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
-                              tag_strings[0], tag_strings[1], tag_strings[2]);
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
       if (ferror (stdin))
-        fatal ("read failed");
+	fatal ("read failed");
     }
   else
     {
@@ -449,10 +402,9 @@ main (int argc, char **argv)
       conflicts_found = false;
     }
 
-  free (b0);
-  free (b1);
   check_stdout ();
   exit (conflicts_found);
+  return conflicts_found;
 }
 
 static void
@@ -460,8 +412,9 @@ try_help (char const *reason_msgid, char
 {
   if (reason_msgid)
     error (0, 0, _(reason_msgid), operand);
-  die (EXIT_TROUBLE, 0,
-         _("Try '%s --help' for more information."), program_name);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
 }
 
 static void
@@ -474,28 +427,23 @@ check_stdout (void)
 }
 
 static char const * const option_help_msgid[] = {
-  N_("-A, --show-all              output all changes, bracketing conflicts"),
-  "",
-  N_("-e, --ed                    output ed script incorporating changes\n"
-     "                                from OLDFILE to YOURFILE into MYFILE"),
-  N_("-E, --show-overlap          like -e, but bracket conflicts"),
-  N_("-3, --easy-only             like -e, but incorporate only nonoverlapping changes"),
-  N_("-x, --overlap-only          like -e, but incorporate only overlapping changes"),
-  N_("-X                          like -x, but bracket conflicts"),
-  N_("-i                          append 'w' and 'q' commands to ed scripts"),
-  "",
-  N_("-m, --merge                 output actual merged file, according to\n"
-     "                                -A if no other options are given"),
+  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
+  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
+  N_("-A  --show-all  Output all changes, bracketing conflicts."),
+  N_("-x  --overlap-only  Output overlapping changes."),
+  N_("-X  Output overlapping changes, bracketing them."),
+  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
   "",
-  N_("-a, --text                  treat all files as text"),
-  N_("    --strip-trailing-cr     strip trailing carriage return on input"),
-  N_("-T, --initial-tab           make tabs line up by prepending a tab"),
-  N_("    --diff-program=PROGRAM  use PROGRAM to compare files"),
-  N_("-L, --label=LABEL           use LABEL instead of file name\n"
-     "                                (can be repeated up to three times)"),
+  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+  N_("-i  Append 'w' and 'q' commands to ed scripts."),
+  N_("-a  --text  Treat all files as text."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
   "",
-  N_("    --help                  display this help and exit"),
-  N_("-v, --version               output version information and exit"),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
   0
 };
 
@@ -505,30 +453,16 @@ usage (void)
   char const * const *p;
 
   printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
-          program_name);
+	  program_name);
   printf ("%s\n\n", _("Compare three files line by line."));
-
-  fputs (_("\
-Mandatory arguments to long options are mandatory for short options too.\n\
-"), stdout);
   for (p = option_help_msgid;  *p;  p++)
     if (**p)
       printf ("  %s\n", _(*p));
     else
       putchar ('\n');
-  fputs (_("\n\
-The default output format is a somewhat human-readable representation of\n\
-the changes.\n\
-\n\
-The -e, -E, -x, -X (and corresponding long) options cause an ed script\n\
-to be output instead of the default.\n\
-\n\
-Finally, the -m (--merge) option causes diff3 to do the merge internally\n\
-and output the actual merged file.  For unusual input, this is more\n\
-robust than using ed.\n"), stdout);
   printf ("\n%s\n%s\n",
-          _("If a FILE is '-', read standard input."),
-          _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
   emit_bug_reporting_address ();
 }
 
@@ -539,43 +473,43 @@ robust than using ed.\n"), stdout);
      Diff02 is the diff between 0 and 2.
      Diff12 is the diff between 1 and 2.
 
-        1) Find the range for the first block in File2.
-            a) Take the lowest of the two ranges (in File2) in the two
-               current blocks (one from each diff) as being the low
-               water mark.  Assign the upper end of this block as
-               being the high water mark and move the current block up
-               one.  Mark the block just moved over as to be used.
-            b) Check the next block in the diff that the high water
-               mark is *not* from.
-
-               *If* the high water mark is above
-               the low end of the range in that block,
-
-                   mark that block as to be used and move the current
-                   block up.  Set the high water mark to the max of
-                   the high end of this block and the current.  Repeat b.
-
-         2) Find the corresponding ranges in File0 (from the blocks
-            in diff02; line per line outside of diffs) and in File1.
-            Create a diff3_block, reserving space as indicated by the ranges.
-
-         3) Copy all of the pointers for file2 in.  At least for now,
-            do memcmp's between corresponding strings in the two diffs.
-
-         4) Copy all of the pointers for file0 and 1 in.  Get what is
-            needed from file2 (when there isn't a diff block, it's
-            identical to file2 within the range between diff blocks).
-
-         5) If the diff blocks used came from only one of the two
-            strings of diffs, then that file (i.e. the one other than
-            the common file in that diff) is the odd person out.  If
-            diff blocks are used from both sets, check to see if files
-            0 and 1 match:
-
-                Same number of lines?  If so, do a set of memcmp's (if
-            a memcmp matches; copy the pointer over; it'll be easier
-            later during comparisons).  If they match, 0 & 1 are the
-            same.  If not, all three different.
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
 
      Then do it again, until the blocks are exhausted.  */
 
@@ -652,12 +586,12 @@ make_3way_diff (struct diff_block *threa
 
       /* Setup low and high water threads, diffs, and marks.  */
       if (!current[0])
-        base_water_thread = 1;
+	base_water_thread = 1;
       else if (!current[1])
-        base_water_thread = 0;
+	base_water_thread = 0;
       else
-        base_water_thread =
-          (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
 
       high_water_thread = base_water_thread;
 
@@ -667,8 +601,8 @@ make_3way_diff (struct diff_block *threa
 
       /* Make the diff you just got info from into the using class */
       using[high_water_thread]
-        = last_using[high_water_thread]
-        = high_water_diff;
+	= last_using[high_water_thread]
+	= high_water_diff;
       current[high_water_thread] = high_water_diff->next;
       last_using[high_water_thread]->next = 0;
 
@@ -677,51 +611,51 @@ make_3way_diff (struct diff_block *threa
       other_diff = current[other_thread];
 
       /* Shuffle up the ladder, checking the other diff to see if it
-         needs to be incorporated.  */
+	 needs to be incorporated.  */
       while (other_diff
-             && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
-        {
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
 
-          /* Incorporate this diff into the using list.  Note that
-             this doesn't take it off the current list */
-          if (using[other_thread])
-            last_using[other_thread]->next = other_diff;
-          else
-            using[other_thread] = other_diff;
-          last_using[other_thread] = other_diff;
-
-          /* Take it off the current list.  Note that this following
-             code assumes that other_diff enters it equal to
-             current[high_water_thread ^ 0x1] */
-          current[other_thread] = current[other_thread]->next;
-          other_diff->next = 0;
-
-          /* Set the high_water stuff
-             If this comparison is equal, then this is the last pass
-             through this loop; since diff blocks within a given
-             thread cannot overlap, the high_water_mark will be
-             *below* the range_start of either of the next diffs.  */
-
-          if (high_water_mark < D_HIGHLINE (other_diff, FC))
-            {
-              high_water_thread ^= 1;
-              high_water_mark = D_HIGHLINE (other_diff, FC);
-            }
-
-          /* Set the other diff */
-          other_thread = high_water_thread ^ 0x1;
-          other_diff = current[other_thread];
-        }
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
 
       /* The using lists contain a list of all of the blocks to be
-         included in this diff3_block.  Create it.  */
+	 included in this diff3_block.  Create it.  */
 
       tmpblock = using_to_diff3_block (using, last_using,
-                                       base_water_thread, high_water_thread,
-                                       last_diff3);
+				       base_water_thread, high_water_thread,
+				       last_diff3);
 
       if (!tmpblock)
-        fatal ("internal error: screwup in format of diff blocks");
+	fatal ("internal error: screwup in format of diff blocks");
 
       /* Put it on the list.  */
       *result_end = tmpblock;
@@ -751,9 +685,9 @@ make_3way_diff (struct diff_block *threa
 
 static struct diff3_block *
 using_to_diff3_block (struct diff_block *using[2],
-                      struct diff_block *last_using[2],
-                      int low_thread, int high_thread,
-                      struct diff3_block const *last_diff3)
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
 {
   lin low[2], high[2];
   struct diff3_block *result;
@@ -772,13 +706,13 @@ using_to_diff3_block (struct diff_block
   for (d = 0; d < 2; d++)
     if (using[d])
       {
-        low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
-        high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
       }
     else
       {
-        low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
-        high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
       }
 
   /* Create a block with the appropriate sizes */
@@ -790,14 +724,14 @@ using_to_diff3_block (struct diff_block
   for (d = 0; d < 2; d++)
     for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
       {
-        lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
 
-        if (!copy_stringlist (D_LINEARRAY (ptr, FC),
-                              D_LENARRAY (ptr, FC),
-                              D_LINEARRAY (result, FILEC) + result_offset,
-                              D_LENARRAY (result, FILEC) + result_offset,
-                              D_NUMLINES (ptr, FC)))
-          return 0;
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
       }
 
   /* Copy information for file d.  First deal with anything that might be
@@ -809,36 +743,36 @@ using_to_diff3_block (struct diff_block
       lin lo = low[d], hi = high[d];
 
       for (i = 0;
-           i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
-           i++)
-        {
-          D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
-          D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
-        }
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
 
       for (ptr = u; ptr; ptr = D_NEXT (ptr))
-        {
-          lin result_offset = D_LOWLINE (ptr, FO) - lo;
-          lin linec;
-
-          if (!copy_stringlist (D_LINEARRAY (ptr, FO),
-                                D_LENARRAY (ptr, FO),
-                                D_LINEARRAY (result, FILE0 + d) + result_offset,
-                                D_LENARRAY (result, FILE0 + d) + result_offset,
-                                D_NUMLINES (ptr, FO)))
-            return 0;
-
-          /* Catch the lines between here and the next diff */
-          linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
-          for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
-               i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
-               i++)
-            {
-              D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
-              D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
-              linec++;
-            }
-        }
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
     }
 
   /* Set correspond */
@@ -852,14 +786,14 @@ using_to_diff3_block (struct diff_block
       lin nl1 = D_NUMLINES (result, FILE1);
 
       if (nl0 != nl1
-          || !compare_line_list (D_LINEARRAY (result, FILE0),
-                                 D_LENARRAY (result, FILE0),
-                                 D_LINEARRAY (result, FILE1),
-                                 D_LENARRAY (result, FILE1),
-                                 nl0))
-        D3_TYPE (result) = DIFF_ALL;
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
       else
-        D3_TYPE (result) = DIFF_3RD;
+	D3_TYPE (result) = DIFF_3RD;
     }
 
   return result;
@@ -872,8 +806,8 @@ using_to_diff3_block (struct diff_block
 
 static bool
 copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
-                 char *toptrs[], size_t tolengths[],
-                 lin copynum)
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
 {
   register char * const *f = fromptrs;
   register char **t = toptrs;
@@ -883,15 +817,15 @@ copy_stringlist (char * const fromptrs[]
   while (copynum--)
     {
       if (*t)
-        {
-          if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
-            return false;
-        }
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
       else
-        {
-          *t = *f;
-          *tl = *fl;
-        }
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
 
       t++; f++; tl++; fl++;
     }
@@ -905,8 +839,8 @@ copy_stringlist (char * const fromptrs[]
 
 static struct diff3_block *
 create_diff3_block (lin low0, lin high0,
-                    lin low1, lin high1,
-                    lin low2, lin high2)
+		    lin low1, lin high1,
+		    lin low2, lin high2)
 {
   struct diff3_block *result = xmalloc (sizeof *result);
   lin numlines;
@@ -968,8 +902,8 @@ create_diff3_block (lin low0, lin high0,
 
 static bool
 compare_line_list (char * const list1[], size_t const lengths1[],
-                   char * const list2[], size_t const lengths2[],
-                   lin nl)
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
 {
   char * const *l1 = list1;
   char * const *l2 = list2;
@@ -978,7 +912,7 @@ compare_line_list (char * const list1[],
 
   while (nl--)
     if (!*l1 || !*l2 || *lgths1 != *lgths2++
-        || memcmp (*l1++, *l2++, *lgths1++) != 0)
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
       return false;
   return true;
 }
@@ -987,9 +921,8 @@ compare_line_list (char * const list1[],
 
 static struct diff_block *
 process_diff (char const *filea,
-              char const *fileb,
-              struct diff_block **last_block,
-              char **buf_to_free)
+	      char const *fileb,
+	      struct diff_block **last_block)
 {
   char *diff_contents;
   char *diff_limit;
@@ -1000,11 +933,10 @@ process_diff (char const *filea,
   struct diff_block **block_list_end = &block_list;
   struct diff_block *bptr IF_LINT (= NULL);
   size_t too_many_lines = (PTRDIFF_MAX
-                           / MIN (sizeof *bptr->lines[1],
-                                  sizeof *bptr->lengths[1]));
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
 
   diff_limit = read_diff (filea, fileb, &diff_contents);
-  *buf_to_free = diff_contents;
   scan_diff = diff_contents;
 
   while (scan_diff < diff_limit)
@@ -1015,74 +947,74 @@ process_diff (char const *filea,
 
       dt = process_diff_control (&scan_diff, bptr);
       if (dt == ERROR || *scan_diff != '\n')
-        {
-          fprintf (stderr, _("%s: diff failed: "), program_name);
-          do
-            {
-              putc (*scan_diff, stderr);
-            }
-          while (*scan_diff++ != '\n');
-          exit (EXIT_TROUBLE);
-        }
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
       scan_diff++;
 
       /* Force appropriate ranges to be null, if necessary */
       switch (dt)
-        {
-        case ADD:
-          bptr->ranges[0][0]++;
-          break;
-        case DELETE:
-          bptr->ranges[1][0]++;
-          break;
-        case CHANGE:
-          break;
-        default:
-          fatal ("internal error: invalid diff type in process_diff");
-          break;
-        }
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
 
       /* Allocate space for the pointers for the lines from filea, and
-         parcel them out among these pointers */
+	 parcel them out among these pointers */
       if (dt != ADD)
-        {
-          lin numlines = D_NUMLINES (bptr, 0);
-          if (too_many_lines <= numlines)
-            xalloc_die ();
-          bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
-          bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
-          for (i = 0; i < numlines; i++)
-            scan_diff = scan_diff_line (scan_diff,
-                                        &(bptr->lines[0][i]),
-                                        &(bptr->lengths[0][i]),
-                                        diff_limit,
-                                        '<');
-        }
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
 
       /* Get past the separator for changes */
       if (dt == CHANGE)
-        {
-          if (strncmp (scan_diff, "---\n", 4))
-            fatal ("invalid diff format; invalid change separator");
-          scan_diff += 4;
-        }
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
 
       /* Allocate space for the pointers for the lines from fileb, and
-         parcel them out among these pointers */
+	 parcel them out among these pointers */
       if (dt != DELETE)
-        {
-          lin numlines = D_NUMLINES (bptr, 1);
-          if (too_many_lines <= numlines)
-            xalloc_die ();
-          bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
-          bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
-          for (i = 0; i < numlines; i++)
-            scan_diff = scan_diff_line (scan_diff,
-                                        &(bptr->lines[1][i]),
-                                        &(bptr->lengths[1][i]),
-                                        diff_limit,
-                                        '>');
-        }
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
 
       /* Place this block on the blocklist.  */
       *block_list_end = bptr;
@@ -1096,7 +1028,7 @@ process_diff (char const *filea,
 
 /* Skip tabs and spaces, and return the first character after them.  */
 
-static char * _GL_ATTRIBUTE_PURE
+static char *
 skipwhite (char *s)
 {
   while (*s == ' ' || *s == '\t')
@@ -1158,7 +1090,7 @@ process_diff_control (char **string, str
     {
       s = readnum (s + 1, &db->ranges[0][RANGE_END]);
       if (! s)
-        return ERROR;
+	return ERROR;
     }
   else
     db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
@@ -1192,7 +1124,7 @@ process_diff_control (char **string, str
     {
       s = readnum (s + 1, &db->ranges[1][RANGE_END]);
       if (! s)
-        return ERROR;
+	return ERROR;
       s = skipwhite (s);		/* To move to end */
     }
   else
@@ -1204,23 +1136,21 @@ process_diff_control (char **string, str
 
 static char *
 read_diff (char const *filea,
-           char const *fileb,
-           char **output_placement)
+	   char const *fileb,
+	   char **output_placement)
 {
   char *diff_result;
   size_t current_chunk_size, total;
   int fd, wstatus, status;
   int werrno = 0;
   struct stat pipestat;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+
   char const *argv[9];
   char const **ap;
-#if HAVE_WORKING_FORK
   int fds[2];
   pid_t pid;
-#else
-  FILE *fpipe;
-  char *command;
-#endif
 
   ap = argv;
   *ap++ = diff_program;
@@ -1234,24 +1164,22 @@ read_diff (char const *filea,
   *ap++ = fileb;
   *ap = 0;
 
-#if HAVE_WORKING_FORK
-
   if (pipe (fds) != 0)
     perror_with_exit ("pipe");
 
-  pid = fork ();
+  pid = vfork ();
   if (pid == 0)
     {
       /* Child */
       close (fds[0]);
       if (fds[1] != STDOUT_FILENO)
-        {
-          dup2 (fds[1], STDOUT_FILENO);
-          close (fds[1]);
-        }
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
 
       /* The cast to (char **) is needed for portability to older
-         hosts with a nonstandard prototype for execvp.  */
+	 hosts with a nonstandard prototype for execvp.  */
       execvp (diff_program, (char **) argv);
 
       _exit (errno == ENOENT ? 127 : 126);
@@ -1265,7 +1193,32 @@ read_diff (char const *filea,
 
 #else
 
-  command = system_quote_argv (SCI_SYSTEM, (char **) argv);
+  FILE *fpipe;
+  char const args[] = " --horizon-lines=100 -- ";
+  char *command = xmalloc (shell_quote_length (diff_program)
+			   + sizeof "-a"
+			   + sizeof "--strip-trailing-cr"
+			   + sizeof args - 1
+			   + shell_quote_length (filea) + 1
+			   + shell_quote_length (fileb) + 1);
+  char *p = command;
+  p = shell_quote_copy (p, diff_program);
+  if (text)
+    {
+      strcpy (p, " -a");
+      p += 3;
+    }
+  if (strip_trailing_cr)
+    {
+      strcpy (p, " --strip-trailing-cr");
+      p += 20;
+    }
+  strcpy (p, args);
+  p += sizeof args - 1;
+  p = shell_quote_copy (p, filea);
+  *p++ = ' ';
+  p = shell_quote_copy (p, fileb);
+  *p = 0;
   errno = 0;
   fpipe = popen (command, "r");
   if (!fpipe)
@@ -1287,13 +1240,13 @@ read_diff (char const *filea,
       size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
       total += bytes;
       if (bytes != bytes_to_read)
-        {
-          if (bytes == SIZE_MAX)
-            perror_with_exit (_("read failed"));
-          break;
-        }
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
       if (PTRDIFF_MAX / 2 <= current_chunk_size)
-        xalloc_die ();
+	xalloc_die ();
       current_chunk_size *= 2;
       diff_result = xrealloc (diff_result, current_chunk_size);
     }
@@ -1303,7 +1256,7 @@ read_diff (char const *filea,
 
   *output_placement = diff_result;
 
-#if ! HAVE_WORKING_FORK
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
 
   wstatus = pclose (fpipe);
   if (wstatus == -1)
@@ -1321,15 +1274,15 @@ read_diff (char const *filea,
   status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
 
   if (EXIT_TROUBLE <= status)
-    die (EXIT_TROUBLE, werrno,
-           _(status == 126
-             ? "subsidiary program '%s' could not be invoked"
-             : status == 127
-             ? "subsidiary program '%s' not found"
-             : status == INT_MAX
-             ? "subsidiary program '%s' failed"
-             : "subsidiary program '%s' failed (exit status %d)"),
-           diff_program, status);
+    error (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program '%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program '%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
+	   diff_program, status);
 
   return diff_result + total;
 }
@@ -1342,12 +1295,12 @@ read_diff (char const *filea,
    are used as call-by-reference values.  */
 static char *
 scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
-                char *limit, char leadingchar)
+		char *limit, char leadingchar)
 {
   char *line_ptr;
 
   if (!(scan_ptr[0] == leadingchar
-        && scan_ptr[1] == ' '))
+	&& scan_ptr[1] == ' '))
     fatal ("invalid diff format; incorrect leading line chars");
 
   *set_start = line_ptr = scan_ptr + 2;
@@ -1363,15 +1316,15 @@ scan_diff_line (char *scan_ptr, char **s
   if (line_ptr < limit && *line_ptr == '\\')
     {
       if (edscript)
-        fprintf (stderr, "%s:", program_name);
+	fprintf (stderr, "%s:", program_name);
       else
-        --*set_length;
+	--*set_length;
       line_ptr++;
       do
-        {
-          if (edscript)
-            putc (*line_ptr, stderr);
-        }
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
       while (*line_ptr++ != '\n');
     }
 
@@ -1388,7 +1341,7 @@ scan_diff_line (char *scan_ptr, char **s
 
 static void
 output_diff3 (FILE *outputfile, struct diff3_block *diff,
-              int const mapping[3], int const rev_mapping[3])
+	      int const mapping[3], int const rev_mapping[3])
 {
   int i;
   int oddoneout;
@@ -1405,68 +1358,68 @@ output_diff3 (FILE *outputfile, struct d
       char x[2];
 
       switch (ptr->correspond)
-        {
-        case DIFF_ALL:
-          x[0] = 0;
-          dontprint = 3;	/* Print them all */
-          oddoneout = 3;	/* Nobody's odder than anyone else */
-          break;
-        case DIFF_1ST:
-        case DIFF_2ND:
-        case DIFF_3RD:
-          oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
-
-          x[0] = oddoneout + '1';
-          x[1] = 0;
-          dontprint = oddoneout == 0;
-          break;
-        default:
-          fatal ("internal error: invalid diff type passed to output");
-        }
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
       fprintf (outputfile, "====%s\n", x);
 
       /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
       for (i = 0; i < 3;
-           i = (oddoneout == 1 ? skew_increment[i] : i + 1))
-        {
-          int realfile = mapping[i];
-          lin lowt = D_LOWLINE (ptr, realfile);
-          lin hight = D_HIGHLINE (ptr, realfile);
-          printint llowt = lowt;
-          printint lhight = hight;
-
-          fprintf (outputfile, "%d:", i + 1);
-          switch (lowt - hight)
-            {
-            case 1:
-              fprintf (outputfile, "%"pI"da\n", llowt - 1);
-              break;
-            case 0:
-              fprintf (outputfile, "%"pI"dc\n", llowt);
-              break;
-            default:
-              fprintf (outputfile, "%"pI"d,%"pI"dc\n", llowt, lhight);
-              break;
-            }
-
-          if (i == dontprint) continue;
-
-          if (lowt <= hight)
-            {
-              line = 0;
-              do
-                {
-                  fputs (line_prefix, outputfile);
-                  cp = D_RELNUM (ptr, realfile, line);
-                  length = D_RELLEN (ptr, realfile, line);
-                  fwrite (cp, sizeof (char), length, outputfile);
-                }
-              while (++line < hight - lowt + 1);
-              if (cp[length - 1] != '\n')
-                fprintf (outputfile, "\n\\ %s\n",
-                         _("No newline at end of file"));
-            }
-        }
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  long int llowt = lowt;
+	  long int lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%lda\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
     }
 }
 
@@ -1486,12 +1439,12 @@ dotlines (FILE *outputfile, struct diff3
     {
       char *line = D_RELNUM (b, filenum, i);
       if (line[0] == '.')
-        {
-          leading_dot = true;
-          fputc ('.', outputfile);
-        }
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
       fwrite (line, sizeof (char),
-              D_RELLEN (b, filenum, i), outputfile);
+	      D_RELLEN (b, filenum, i), outputfile);
     }
 
   return leading_dot;
@@ -1499,18 +1452,19 @@ dotlines (FILE *outputfile, struct diff3
 
 /* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
    output a command that removes initial '.'s starting with line START
-   and continuing for NUM lines.  */
+   and continuing for NUM lines.  (START is long int, not lin, for
+   convenience with printf %ld formats.)  */
 
 static void
-undotlines (FILE *outputfile, bool leading_dot, printint start, printint num)
+undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
 {
   fputs (".\n", outputfile);
   if (leading_dot)
     {
       if (num == 1)
-        fprintf (outputfile, "%"pI"ds/^\\.//\n", start);
+	fprintf (outputfile, "%lds/^\\.//\n", start);
       else
-        fprintf (outputfile, "%"pI"d,%"pI"ds/^\\.//\n", start, start + num - 1);
+	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
     }
 }
 
@@ -1535,8 +1489,8 @@ undotlines (FILE *outputfile, bool leadi
 
 static bool
 output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
-                       int const mapping[3], int const rev_mapping[3],
-                       char const *file0, char const *file1, char const *file2)
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
 {
   bool leading_dot;
   bool conflicts_found = false;
@@ -1547,92 +1501,92 @@ output_diff3_edscript (FILE *outputfile,
     {
       /* Must do mapping correctly.  */
       enum diff_type type
-        = (b->correspond == DIFF_ALL
-           ? DIFF_ALL
-           : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
 
-      printint low0, high0;
+      long int low0, high0;
 
       /* If we aren't supposed to do this output block, skip it.  */
       switch (type)
-        {
-        default: continue;
-        case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
-        case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
-        case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
-        }
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
 
       low0 = D_LOWLINE (b, mapping[FILE0]);
       high0 = D_HIGHLINE (b, mapping[FILE0]);
 
       if (conflict)
-        {
-          conflicts_found = true;
+	{
+	  conflicts_found = true;
 
 
-          /* Mark end of conflict.  */
+	  /* Mark end of conflict.  */
 
-          fprintf (outputfile, "%"pI"da\n", high0);
-          leading_dot = false;
-          if (type == DIFF_ALL)
-            {
-              if (show_2nd)
-                {
-                  /* Append lines from FILE1.  */
-                  fprintf (outputfile, "||||||| %s\n", file1);
-                  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
-                }
-              /* Append lines from FILE2.  */
-              fputs ("=======\n", outputfile);
-              leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
-            }
-          fprintf (outputfile, ">>>>>>> %s\n", file2);
-          undotlines (outputfile, leading_dot, high0 + 2,
-                      (D_NUMLINES (b, mapping[FILE1])
-                       + D_NUMLINES (b, mapping[FILE2]) + 1));
-
-
-          /* Mark start of conflict.  */
-
-          fprintf (outputfile, "%"pI"da\n<<<<<<< %s\n", low0 - 1,
-                   type == DIFF_ALL ? file0 : file1);
-          leading_dot = false;
-          if (type == DIFF_2ND)
-            {
-              /* Prepend lines from FILE1.  */
-              leading_dot = dotlines (outputfile, b, mapping[FILE1]);
-              fputs ("=======\n", outputfile);
-            }
-          undotlines (outputfile, leading_dot, low0 + 1,
-                      D_NUMLINES (b, mapping[FILE1]));
-        }
+	  fprintf (outputfile, "%lda\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
       else if (D_NUMLINES (b, mapping[FILE2]) == 0)
-        /* Write out a delete */
-        {
-          if (low0 == high0)
-            fprintf (outputfile, "%"pI"dd\n", low0);
-          else
-            fprintf (outputfile, "%"pI"d,%"pI"dd\n", low0, high0);
-        }
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%ldd\n", low0);
+	  else
+	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+	}
       else
-        /* Write out an add or change */
-        {
-          switch (high0 - low0)
-            {
-            case -1:
-              fprintf (outputfile, "%"pI"da\n", high0);
-              break;
-            case 0:
-              fprintf (outputfile, "%"pI"dc\n", high0);
-              break;
-            default:
-              fprintf (outputfile, "%"pI"d,%"pI"dc\n", low0, high0);
-              break;
-            }
-
-          undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
-                      low0, D_NUMLINES (b, mapping[FILE2]));
-        }
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%lda\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
     }
   if (finalwrite)
     fputs ("w\nq\n", outputfile);
@@ -1652,8 +1606,8 @@ output_diff3_edscript (FILE *outputfile,
 
 static bool
 output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
-                    int const mapping[3], int const rev_mapping[3],
-                    char const *file0, char const *file1, char const *file2)
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
 {
   int c;
   lin i;
@@ -1666,95 +1620,95 @@ output_diff3_merge (FILE *infile, FILE *
     {
       /* Must do mapping correctly.  */
       enum diff_type type
-        = ((b->correspond == DIFF_ALL)
-           ? DIFF_ALL
-           : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
       char const *format_2nd = "<<<<<<< %s\n";
 
       /* If we aren't supposed to do this output block, skip it.  */
       switch (type)
-        {
-        default: continue;
-        case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
-        case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
-        case DIFF_ALL: if (simple_only) continue; conflict = flagging;
-          format_2nd = "||||||| %s\n";
-          break;
-        }
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
 
       /* Copy I lines from file 0.  */
       i = D_LOWLINE (b, FILE0) - linesread - 1;
       linesread += i;
       while (0 <= --i)
-        do
-          {
-            c = getc (infile);
-            if (c == EOF)
-              {
-                if (ferror (infile))
-                  perror_with_exit (_("read failed"));
-                else if (feof (infile))
-                  fatal ("input file shrank");
-              }
-            putc (c, outputfile);
-          }
-        while (c != '\n');
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
 
       if (conflict)
-        {
-          conflicts_found = true;
+	{
+	  conflicts_found = true;
 
-          if (type == DIFF_ALL)
-            {
-              /* Put in lines from FILE0 with bracket.  */
-              fprintf (outputfile, "<<<<<<< %s\n", file0);
-              for (i = 0;
-                   i < D_NUMLINES (b, mapping[FILE0]);
-                   i++)
-                fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
-                        D_RELLEN (b, mapping[FILE0], i), outputfile);
-            }
-
-          if (show_2nd)
-            {
-              /* Put in lines from FILE1 with bracket.  */
-              fprintf (outputfile, format_2nd, file1);
-              for (i = 0;
-                   i < D_NUMLINES (b, mapping[FILE1]);
-                   i++)
-                fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
-                        D_RELLEN (b, mapping[FILE1], i), outputfile);
-            }
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
 
-          fputs ("=======\n", outputfile);
-        }
+	  fputs ("=======\n", outputfile);
+	}
 
       /* Put in lines from FILE2.  */
       for (i = 0;
-           i < D_NUMLINES (b, mapping[FILE2]);
-           i++)
-        fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
-                D_RELLEN (b, mapping[FILE2], i), outputfile);
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
 
       if (conflict)
-        fprintf (outputfile, ">>>>>>> %s\n", file2);
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
 
       /* Skip I lines in file 0.  */
       i = D_NUMLINES (b, FILE0);
       linesread += i;
       while (0 <= --i)
-        while ((c = getc (infile)) != '\n')
-          if (c == EOF)
-            {
-              if (ferror (infile))
-                perror_with_exit (_("read failed"));
-              else if (feof (infile))
-                {
-                  if (i || b->next)
-                    fatal ("input file shrank");
-                  return conflicts_found;
-                }
-            }
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
     }
   /* Copy rest of common file.  */
   while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
@@ -1778,15 +1732,17 @@ reverse_diff3_blocklist (struct diff3_bl
 
   return prev;
 }
-
+
 static void
 fatal (char const *msgid)
 {
-  die (EXIT_TROUBLE, 0, "%s", _(msgid));
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
 }
 
 static void
 perror_with_exit (char const *string)
 {
-  die (EXIT_TROUBLE, errno, "%s", string);
+  error (EXIT_TROUBLE, errno, "%s", string);
+  abort ();
 }
diff -pru diffutils-3.0/diff.c diffutils-3.0-patch/diff.c
--- diffutils-3.0/diff.c	2020-05-30 16:24:16.377937000 -0700
+++ diffutils-3.0-patch/diff.c	2020-05-30 15:52:03.058071000 -0700
@@ -1,7 +1,8 @@
-/* GNU diff - compare files line by line
+
+/* diff - compare files line by line
 
    Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
-   2009-2013, 2015-2020 Free Software Foundation, Inc.
+   2009-2010 Free Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -20,7 +21,6 @@
 
 #define GDIFF_MAIN
 #include "diff.h"
-#include "die.h"
 #include <assert.h>
 #include "paths.h"
 #include <c-stack.h>
@@ -28,7 +28,6 @@
 #include <error.h>
 #include <exclude.h>
 #include <exitfail.h>
-#include <filenamecat.h>
 #include <file-type.h>
 #include <fnmatch.h>
 #include <getopt.h>
@@ -40,9 +39,7 @@
 #include <timespec.h>
 #include <version-etc.h>
 #include <xalloc.h>
-#include <xreadlink.h>
-#include <xstdopen.h>
-#include <binary-io.h>
+#include <xfreopen.h>
 
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "diff"
@@ -72,7 +69,6 @@ static void add_regexp (struct regexp_li
 static void summarize_regexp_list (struct regexp_list *);
 static void specify_style (enum output_style);
 static void specify_value (char const **, char const *, char const *);
-static void specify_colors_style (char const *);
 static void try_help (char const *, char const *) __attribute__((noreturn));
 static void check_stdout (void);
 static void usage (void);
@@ -95,11 +91,15 @@ static bool binary;
 enum { binary = true };
 #endif
 
-/* If one file is missing, treat it as present but empty (-N).  */
+/* When comparing directories, if a file appears only in one
+   directory, treat it as present but empty in the other (-N).
+   Then 'patch' would create the file with appropriate contents.  */
 static bool new_file;
 
-/* If the first file is missing, treat it as present but empty
-   (--unidirectional-new-file).  */
+/* When comparing directories, if a file appears only in the second
+   directory of the two, treat it as present but empty in the other
+   (--unidirectional-new-file).
+   Then 'patch' would create the file with appropriate contents.  */
 static bool unidirectional_new_file;
 
 /* Report files compared that are the same (-s).
@@ -107,7 +107,7 @@ static bool unidirectional_new_file;
 static bool report_identical_files;
 
 static char const shortopts[] =
-"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:yZ";
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
 
 /* Values for long options that do not have single-letter equivalents.  */
 enum
@@ -120,7 +120,6 @@ enum
   INHIBIT_HUNK_MERGE_OPTION,
   LEFT_COLUMN_OPTION,
   LINE_FORMAT_OPTION,
-  NO_DEREFERENCE_OPTION,
   NO_IGNORE_FILE_NAME_CASE_OPTION,
   NORMAL_OPTION,
   SDIFF_MERGE_ASSIST_OPTION,
@@ -139,12 +138,7 @@ enum
   UNCHANGED_GROUP_FORMAT_OPTION,
   OLD_GROUP_FORMAT_OPTION,
   NEW_GROUP_FORMAT_OPTION,
-  CHANGED_GROUP_FORMAT_OPTION,
-
-  COLOR_OPTION,
-  COLOR_PALETTE_OPTION,
-
-  PRESUME_OUTPUT_TTY_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION
 };
 
 static char const group_format_option[][sizeof "--unchanged-group-format"] =
@@ -167,7 +161,6 @@ static struct option const longopts[] =
   {"binary", 0, 0, BINARY_OPTION},
   {"brief", 0, 0, 'q'},
   {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
-  {"color", 2, 0, COLOR_OPTION},
   {"context", 2, 0, 'C'},
   {"ed", 0, 0, 'e'},
   {"exclude", 1, 0, 'x'},
@@ -185,7 +178,6 @@ static struct option const longopts[] =
   {"ignore-matching-lines", 1, 0, 'I'},
   {"ignore-space-change", 0, 0, 'b'},
   {"ignore-tab-expansion", 0, 0, 'E'},
-  {"ignore-trailing-space", 0, 0, 'Z'},
   {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
   {"initial-tab", 0, 0, 'T'},
   {"label", 1, 0, 'L'},
@@ -195,13 +187,11 @@ static struct option const longopts[] =
   {"new-file", 0, 0, 'N'},
   {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
   {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
-  {"no-dereference", 0, 0, NO_DEREFERENCE_OPTION},
   {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
   {"normal", 0, 0, NORMAL_OPTION},
   {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
   {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
   {"paginate", 0, 0, 'l'},
-  {"palette", 1, 0, COLOR_PALETTE_OPTION},
   {"rcs", 0, 0, 'n'},
   {"recursive", 0, 0, 'r'},
   {"report-identical-files", 0, 0, 's'},
@@ -223,9 +213,6 @@ static struct option const longopts[] =
   {"unified", 2, 0, 'U'},
   {"version", 0, 0, 'v'},
   {"width", 1, 0, 'W'},
-
-  /* This is solely for testing.  Do not document.  */
-  {"-presume-output-tty", no_argument, NULL, PRESUME_OUTPUT_TTY_OPTION},
   {0, 0, 0, 0}
 };
 
@@ -282,7 +269,7 @@ main (int argc, char **argv)
   bool show_c_function = false;
   char const *from_file = NULL;
   char const *to_file = NULL;
-  intmax_t numval;
+  uintmax_t numval;
   char *numend;
 
   /* Do our initializations.  */
@@ -297,386 +284,354 @@ main (int argc, char **argv)
   ignore_regexp_list.buf = &ignore_regexp;
   re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
   excluded = new_exclude ();
-  presume_output_tty = false;
-  xstdopen ();
 
   /* Decode the options.  */
 
   while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
     {
       switch (c)
-        {
-        case 0:
-          break;
-
-        case '0':
-        case '1':
-        case '2':
-        case '3':
-        case '4':
-        case '5':
-        case '6':
-        case '7':
-        case '8':
-        case '9':
-          ocontext = (! ISDIGIT (prev)
-                      ? c - '0'
-                      : (ocontext - (c - '0' <= CONTEXT_MAX % 10)
-                         < CONTEXT_MAX / 10)
-                      ? 10 * ocontext + (c - '0')
-                      : CONTEXT_MAX);
-          break;
-
-        case 'a':
-          text = true;
-          break;
-
-        case 'b':
-          if (ignore_white_space < IGNORE_SPACE_CHANGE)
-            ignore_white_space = IGNORE_SPACE_CHANGE;
-          break;
-
-        case 'Z':
-          if (ignore_white_space < IGNORE_SPACE_CHANGE)
-            ignore_white_space |= IGNORE_TRAILING_SPACE;
-          break;
-
-        case 'B':
-          ignore_blank_lines = true;
-          break;
-
-        case 'C':
-        case 'U':
-          {
-            if (optarg)
-              {
-                numval = strtoimax (optarg, &numend, 10);
-                if (*numend || numval < 0)
-                  try_help ("invalid context length '%s'", optarg);
-                if (CONTEXT_MAX < numval)
-                  numval = CONTEXT_MAX;
-              }
-            else
-              numval = 3;
-
-            specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
-            if (context < numval)
-              context = numval;
-            explicit_context = true;
-          }
-          break;
-
-        case 'c':
-          specify_style (OUTPUT_CONTEXT);
-          if (context < 3)
-            context = 3;
-          break;
-
-        case 'd':
-          minimal = true;
-          break;
-
-        case 'D':
-          specify_style (OUTPUT_IFDEF);
-          {
-            static char const C_ifdef_group_formats[] =
-              "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
-            char *b = xmalloc (sizeof C_ifdef_group_formats
-                               + 7 * strlen (optarg) - 14 /* 7*"%s" */
-                               - 8 /* 5*"%%" + 3*"%c" */);
-            sprintf (b, C_ifdef_group_formats,
-                     0,
-                     optarg, optarg, 0,
-                     optarg, optarg, 0,
-                     optarg, optarg, optarg);
-            for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
-              {
-                specify_value (&group_format[i], b, "-D");
-                b += strlen (b) + 1;
-              }
-          }
-          break;
-
-        case 'e':
-          specify_style (OUTPUT_ED);
-          break;
-
-        case 'E':
-          if (ignore_white_space < IGNORE_SPACE_CHANGE)
-            ignore_white_space |= IGNORE_TAB_EXPANSION;
-          break;
-
-        case 'f':
-          specify_style (OUTPUT_FORWARD_ED);
-          break;
-
-        case 'F':
-          add_regexp (&function_regexp_list, optarg);
-          break;
-
-        case 'h':
-          /* Split the files into chunks for faster processing.
-             Usually does not change the result.
-
-             This currently has no effect.  */
-          break;
-
-        case 'H':
-          speed_large_files = true;
-          break;
-
-        case 'i':
-          ignore_case = true;
-          break;
-
-        case 'I':
-          add_regexp (&ignore_regexp_list, optarg);
-          break;
-
-        case 'l':
-          if (!pr_program[0])
-            try_help ("pagination not supported on this host", NULL);
-          paginate = true;
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (! ISDIGIT (prev))
+	    ocontext = c - '0';
+	  else if (LIN_MAX / 10 < ocontext
+		   || ((ocontext = 10 * ocontext + c - '0') < 0))
+	    ocontext = LIN_MAX;
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length '%s'", optarg);
+		if (LIN_MAX < numval)
+		  numval = LIN_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
+	    ignore_white_space = IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
 #ifdef SIGCHLD
-          /* Pagination requires forking and waiting, and
-             System V fork+wait does not work if SIGCHLD is ignored.  */
-          signal (SIGCHLD, SIG_DFL);
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
 #endif
-          break;
+	  break;
 
-        case 'L':
-          if (!file_label[0])
-            file_label[0] = optarg;
-          else if (!file_label[1])
-            file_label[1] = optarg;
-          else
-            fatal ("too many file label options");
-          break;
-
-        case 'n':
-          specify_style (OUTPUT_RCS);
-          break;
-
-        case 'N':
-          new_file = true;
-          break;
-
-        case 'p':
-          show_c_function = true;
-          add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
-          break;
-
-        case 'P':
-          unidirectional_new_file = true;
-          break;
-
-        case 'q':
-          brief = true;
-          break;
-
-        case 'r':
-          recursive = true;
-          break;
-
-        case 's':
-          report_identical_files = true;
-          break;
-
-        case 'S':
-          specify_value (&starting_file, optarg, "-S");
-          break;
-
-        case 't':
-          expand_tabs = true;
-          break;
-
-        case 'T':
-          initial_tab = true;
-          break;
-
-        case 'u':
-          specify_style (OUTPUT_UNIFIED);
-          if (context < 3)
-            context = 3;
-          break;
-
-        case 'v':
-          version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
-                       AUTHORS, (char *) NULL);
-          check_stdout ();
-          return EXIT_SUCCESS;
-
-        case 'w':
-          ignore_white_space = IGNORE_ALL_SPACE;
-          break;
-
-        case 'x':
-          add_exclude (excluded, optarg, exclude_options ());
-          break;
-
-        case 'X':
-          if (add_exclude_file (add_exclude, excluded, optarg,
-                                exclude_options (), '\n'))
-            pfatal_with_name (optarg);
-          break;
-
-        case 'y':
-          specify_style (OUTPUT_SDIFF);
-          break;
-
-        case 'W':
-          numval = strtoimax (optarg, &numend, 10);
-          if (! (0 < numval && numval <= SIZE_MAX) || *numend)
-            try_help ("invalid width '%s'", optarg);
-          if (width != numval)
-            {
-              if (width)
-                fatal ("conflicting width options");
-              width = numval;
-            }
-          break;
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width '%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
 
-        case BINARY_OPTION:
+	case BINARY_OPTION:
 #if O_BINARY
-          binary = true;
-          if (! isatty (STDOUT_FILENO))
-            set_binary_mode (STDOUT_FILENO, O_BINARY);
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    xfreopen (NULL, "wb", stdout);
 #endif
-          break;
+	  break;
 
-        case FROM_FILE_OPTION:
-          specify_value (&from_file, optarg, "--from-file");
-          break;
-
-        case HELP_OPTION:
-          usage ();
-          check_stdout ();
-          return EXIT_SUCCESS;
-
-        case HORIZON_LINES_OPTION:
-          numval = strtoimax (optarg, &numend, 10);
-          if (*numend || numval < 0)
-            try_help ("invalid horizon length '%s'", optarg);
-          horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
-          break;
-
-        case IGNORE_FILE_NAME_CASE_OPTION:
-          ignore_file_name_case = true;
-          break;
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length '%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
 
-        case INHIBIT_HUNK_MERGE_OPTION:
-          /* This option is obsolete, but accept it for backward
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
              compatibility.  */
-          break;
+	  break;
 
-        case LEFT_COLUMN_OPTION:
-          left_column = true;
-          break;
-
-        case LINE_FORMAT_OPTION:
-          specify_style (OUTPUT_IFDEF);
-          for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
-            specify_value (&line_format[i], optarg, "--line-format");
-          break;
-
-        case NO_DEREFERENCE_OPTION:
-          no_dereference_symlinks = true;
-          break;
-
-        case NO_IGNORE_FILE_NAME_CASE_OPTION:
-          ignore_file_name_case = false;
-          break;
-
-        case NORMAL_OPTION:
-          specify_style (OUTPUT_NORMAL);
-          break;
-
-        case SDIFF_MERGE_ASSIST_OPTION:
-          specify_style (OUTPUT_SDIFF);
-          sdiff_merge_assist = true;
-          break;
-
-        case STRIP_TRAILING_CR_OPTION:
-          strip_trailing_cr = true;
-          break;
-
-        case SUPPRESS_BLANK_EMPTY_OPTION:
-          suppress_blank_empty = true;
-          break;
-
-        case SUPPRESS_COMMON_LINES_OPTION:
-          suppress_common_lines = true;
-          break;
-
-        case TABSIZE_OPTION:
-          numval = strtoimax (optarg, &numend, 10);
-          if (! (0 < numval && numval <= SIZE_MAX - GUTTER_WIDTH_MINIMUM)
-              || *numend)
-            try_help ("invalid tabsize '%s'", optarg);
-          if (tabsize != numval)
-            {
-              if (tabsize)
-                fatal ("conflicting tabsize options");
-              tabsize = numval;
-            }
-          break;
-
-        case TO_FILE_OPTION:
-          specify_value (&to_file, optarg, "--to-file");
-          break;
-
-        case UNCHANGED_LINE_FORMAT_OPTION:
-        case OLD_LINE_FORMAT_OPTION:
-        case NEW_LINE_FORMAT_OPTION:
-          specify_style (OUTPUT_IFDEF);
-          c -= UNCHANGED_LINE_FORMAT_OPTION;
-          specify_value (&line_format[c], optarg, line_format_option[c]);
-          break;
-
-        case UNCHANGED_GROUP_FORMAT_OPTION:
-        case OLD_GROUP_FORMAT_OPTION:
-        case NEW_GROUP_FORMAT_OPTION:
-        case CHANGED_GROUP_FORMAT_OPTION:
-          specify_style (OUTPUT_IFDEF);
-          c -= UNCHANGED_GROUP_FORMAT_OPTION;
-          specify_value (&group_format[c], optarg, group_format_option[c]);
-          break;
-
-        case COLOR_OPTION:
-          specify_colors_style (optarg);
-          break;
-
-        case COLOR_PALETTE_OPTION:
-          set_color_palette (optarg);
-          break;
-
-        case PRESUME_OUTPUT_TTY_OPTION:
-          presume_output_tty = true;
-          break;
-
-        default:
-          try_help (NULL, NULL);
-        }
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid tabsize '%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
       prev = c;
     }
 
-  if (colors_style == AUTO)
-    {
-      char const *t = getenv ("TERM");
-      if (t && STREQ (t, "dumb"))
-        colors_style = NEVER;
-    }
-
   if (output_style == OUTPUT_UNSPECIFIED)
     {
       if (show_c_function)
-        {
-          specify_style (OUTPUT_CONTEXT);
-          if (ocontext < 0)
-            context = 3;
-        }
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
       else
-        specify_style (OUTPUT_NORMAL);
+	specify_style (OUTPUT_NORMAL);
     }
 
   if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
@@ -696,9 +651,9 @@ main (int argc, char **argv)
 
   if (0 <= ocontext
       && (output_style == OUTPUT_CONTEXT
-          || output_style == OUTPUT_UNIFIED)
+	  || output_style == OUTPUT_UNIFIED)
       && (context < ocontext
-          || (ocontext < context && ! explicit_context)))
+	  || (ocontext < context && ! explicit_context)))
     context = ocontext;
 
   if (! tabsize)
@@ -710,21 +665,17 @@ main (int argc, char **argv)
     /* Maximize first the half line width, and then the gutter width,
        according to the following constraints:
 
-        1.  Two half lines plus a gutter must fit in a line.
-        2.  If the half line width is nonzero:
-            a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
-            b.  If tabs are not expanded to spaces,
-                a half line plus a gutter is an integral number of tabs,
-                so that tabs in the right column line up.  */
-
-    size_t t = expand_tabs ? 1 : tabsize;
-    size_t w = width;
-    size_t t_plus_g = t + GUTTER_WIDTH_MINIMUM;
-    size_t unaligned_off = (w >> 1) + (t_plus_g >> 1) + (w & t_plus_g & 1);
-    size_t off = unaligned_off - unaligned_off % t;
-    sdiff_half_width = (off <= GUTTER_WIDTH_MINIMUM || w <= off
-                        ? 0
-                        : MIN (off - GUTTER_WIDTH_MINIMUM, w - off));
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    intmax_t t = expand_tabs ? 1 : tabsize;
+    intmax_t w = width;
+    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
+    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
     sdiff_column2_offset = sdiff_half_width ? off : w;
   }
 
@@ -739,68 +690,68 @@ main (int argc, char **argv)
   if (output_style == OUTPUT_IFDEF)
     {
       for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
-        if (!line_format[i])
-          line_format[i] = "%l\n";
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
       if (!group_format[OLD])
-        group_format[OLD]
-          = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
       if (!group_format[NEW])
-        group_format[NEW]
-          = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
       if (!group_format[UNCHANGED])
-        group_format[UNCHANGED] = "%=";
+	group_format[UNCHANGED] = "%=";
       if (!group_format[CHANGED])
-        group_format[CHANGED] = concat (group_format[OLD],
-                                        group_format[NEW], "");
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
     }
 
   no_diff_means_no_output =
     (output_style == OUTPUT_IFDEF ?
       (!*group_format[UNCHANGED]
        || (STREQ (group_format[UNCHANGED], "%=")
-           && !*line_format[UNCHANGED]))
+	   && !*line_format[UNCHANGED]))
      : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
 
   files_can_be_treated_as_binary =
     (brief & binary
      & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
-          | (ignore_regexp_list.regexps || ignore_white_space)));
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
 
   switch_string = option_list (argv + 1, optind - 1);
 
   if (from_file)
     {
       if (to_file)
-        fatal ("--from-file and --to-file both specified");
+	fatal ("--from-file and --to-file both specified");
       else
-        for (; optind < argc; optind++)
-          {
-            int status = compare_files (NULL, from_file, argv[optind]);
-            if (exit_status < status)
-              exit_status = status;
-          }
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
     }
   else
     {
       if (to_file)
-        for (; optind < argc; optind++)
-          {
-            int status = compare_files (NULL, argv[optind], to_file);
-            if (exit_status < status)
-              exit_status = status;
-          }
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
       else
-        {
-          if (argc - optind != 2)
-            {
-              if (argc - optind < 2)
-                try_help ("missing operand after '%s'", argv[argc - 1]);
-              else
-                try_help ("extra operand '%s'", argv[optind + 2]);
-            }
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after '%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand '%s'", argv[optind + 2]);
+	    }
 
-          exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
-        }
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
     }
 
   /* Print any messages that were saved up for last.  */
@@ -820,7 +771,7 @@ add_regexp (struct regexp_list *reglist,
   char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
 
   if (m != 0)
-    error (EXIT_TROUBLE, 0, "%s: %s", pattern, m);
+    error (0, 0, "%s: %s", pattern, m);
   else
     {
       char *regexps = reglist->regexps;
@@ -830,21 +781,21 @@ add_regexp (struct regexp_list *reglist,
       size_t size = reglist->size;
 
       if (size <= newlen)
-        {
-          if (!size)
-            size = 1;
-
-          do size *= 2;
-          while (size <= newlen);
-
-          reglist->size = size;
-          reglist->regexps = regexps = xrealloc (regexps, size);
-        }
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
       if (multiple_regexps)
-        {
-          regexps[len++] = '\\';
-          regexps[len++] = '|';
-        }
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
       memcpy (regexps + len, pattern, patlen + 1);
     }
 }
@@ -860,14 +811,14 @@ summarize_regexp_list (struct regexp_lis
       /* At least one regexp was specified.  Allocate a fastmap for it.  */
       reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
       if (reglist->multiple_regexps)
-        {
-          /* Compile the disjunction of the regexps.
-             (If just one regexp was specified, it is already compiled.)  */
-          char const *m = re_compile_pattern (reglist->regexps, reglist->len,
-                                              reglist->buf);
-          if (m)
-            die (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
-        }
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
     }
 }
 
@@ -876,8 +827,9 @@ try_help (char const *reason_msgid, char
 {
   if (reason_msgid)
     error (0, 0, _(reason_msgid), operand);
-  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
-         program_name);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
 }
 
 static void
@@ -890,65 +842,41 @@ check_stdout (void)
 }
 
 static char const * const option_help_msgid[] = {
-  N_("    --normal                  output a normal diff (the default)"),
-  N_("-q, --brief                   report only when files differ"),
-  N_("-s, --report-identical-files  report when two files are the same"),
-  N_("-c, -C NUM, --context[=NUM]   output NUM (default 3) lines of copied context"),
-  N_("-u, -U NUM, --unified[=NUM]   output NUM (default 3) lines of unified context"),
-  N_("-e, --ed                      output an ed script"),
-  N_("-n, --rcs                     output an RCS format diff"),
-  N_("-y, --side-by-side            output in two columns"),
-  N_("-W, --width=NUM               output at most NUM (default 130) print columns"),
-  N_("    --left-column             output only the left column of common lines"),
-  N_("    --suppress-common-lines   do not output common lines"),
-  "",
-  N_("-p, --show-c-function         show which C function each change is in"),
-  N_("-F, --show-function-line=RE   show the most recent line matching RE"),
-  N_("    --label LABEL             use LABEL instead of file name and timestamp\n"
-     "                                (can be repeated)"),
-  "",
-  N_("-t, --expand-tabs             expand tabs to spaces in output"),
-  N_("-T, --initial-tab             make tabs line up by prepending a tab"),
-  N_("    --tabsize=NUM             tab stops every NUM (default 8) print columns"),
-  N_("    --suppress-blank-empty    suppress space or tab before empty output lines"),
-  N_("-l, --paginate                pass output through 'pr' to paginate it"),
-  "",
-  N_("-r, --recursive                 recursively compare any subdirectories found"),
-  N_("    --no-dereference            don't follow symbolic links"),
-  N_("-N, --new-file                  treat absent files as empty"),
-  N_("    --unidirectional-new-file   treat absent first files as empty"),
-  N_("    --ignore-file-name-case     ignore case when comparing file names"),
-  N_("    --no-ignore-file-name-case  consider case when comparing file names"),
-  N_("-x, --exclude=PAT               exclude files that match PAT"),
-  N_("-X, --exclude-from=FILE         exclude files that match any pattern in FILE"),
-  N_("-S, --starting-file=FILE        start with FILE when comparing directories"),
-  N_("    --from-file=FILE1           compare FILE1 to all operands;\n"
-     "                                  FILE1 can be a directory"),
-  N_("    --to-file=FILE2             compare all operands to FILE2;\n"
-     "                                  FILE2 can be a directory"),
-  "",
-  N_("-i, --ignore-case               ignore case differences in file contents"),
-  N_("-E, --ignore-tab-expansion      ignore changes due to tab expansion"),
-  N_("-Z, --ignore-trailing-space     ignore white space at line end"),
-  N_("-b, --ignore-space-change       ignore changes in the amount of white space"),
-  N_("-w, --ignore-all-space          ignore all white space"),
-  N_("-B, --ignore-blank-lines        ignore changes where lines are all blank"),
-  N_("-I, --ignore-matching-lines=RE  ignore changes where all lines match RE"),
+  N_("Compare files line by line."),
   "",
-  N_("-a, --text                      treat all files as text"),
-  N_("    --strip-trailing-cr         strip trailing carriage return on input"),
+  N_("-i  --ignore-case  Ignore case differences in file contents."),
+  N_("--ignore-file-name-case  Ignore case when comparing file names."),
+  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-w  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
 #if O_BINARY
-  N_("    --binary                    read and write data in binary mode"),
+  N_("--binary  Read and write data in binary mode."),
 #endif
+  N_("-a  --text  Treat all files as text."),
   "",
-  N_("-D, --ifdef=NAME                output merged file with '#ifdef NAME' diffs"),
-  N_("    --GTYPE-group-format=GFMT   format GTYPE input groups with GFMT"),
-  N_("    --line-format=LFMT          format all input lines with LFMT"),
-  N_("    --LTYPE-line-format=LFMT    format LTYPE input lines with LFMT"),
-  N_("  These format options provide fine-grained control over the output\n"
-     "    of diff, generalizing -D/--ifdef."),
+  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
+-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
+  --label LABEL  Use LABEL instead of file name.\n\
+  -p  --show-c-function  Show which C function each change is in.\n\
+  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
+  N_("-q  --brief  Output only whether files differ."),
+  N_("-e  --ed  Output an ed script."),
+  N_("--normal  Output a normal diff."),
+  N_("-n  --rcs  Output an RCS format diff."),
+  N_("-y  --side-by-side  Output in two columns.\n\
+  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+  --left-column  Output only the left column of common lines.\n\
+  --suppress-common-lines  Do not output common lines."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
+  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
   N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
-  N_("  GFMT (only) may contain:\n\
+  N_("  GFMT may contain:\n\
     %<  lines from FILE1\n\
     %>  lines from FILE2\n\
     %=  lines common to FILE1 and FILE2\n\
@@ -958,31 +886,41 @@ static char const * const option_help_ms
         L  last line number\n\
         N  number of lines = L-F+1\n\
         E  F-1\n\
-        M  L+1\n\
-    %(A=B?T:E)  if A equals B then T else E"),
-  N_("  LFMT (only) may contain:\n\
+        M  L+1"),
+  N_("  LFMT may contain:\n\
     %L  contents of line\n\
     %l  contents of line, excluding any trailing newline\n\
     %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
-  N_("  Both GFMT and LFMT may contain:\n\
+  N_("  Either GFMT or LFMT may contain:\n\
     %%  %\n\
     %c'C'  the single character C\n\
-    %c'\\OOO'  the character with octal code OOO\n\
-    C    the character C (other characters represent themselves)"),
+    %c'\\OOO'  the character with octal code OOO"),
   "",
-  N_("-d, --minimal            try hard to find a smaller set of changes"),
-  N_("    --horizon-lines=NUM  keep NUM lines of the common prefix and suffix"),
-  N_("    --speed-large-files  assume large files and many scattered small changes"),
-  N_("    --color[=WHEN]       colorize the output; WHEN can be 'never', 'always',\n"
-     "                           or 'auto' (the default)"),
-  N_("    --palette=PALETTE    the colors to use when --color is active; PALETTE is\n"
-     "                           a colon-separated list of terminfo capabilities"),
+  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
   "",
-  N_("    --help               display this help and exit"),
-  N_("-v, --version            output version information and exit"),
+  N_("-r  --recursive  Recursively compare any subdirectories found."),
+  N_("-N  --new-file  Treat absent files as empty."),
+  N_("--unidirectional-new-file  Treat absent first files as empty."),
+  N_("-s  --report-identical-files  Report when two files are the same."),
+  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
+  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
+  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
+  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
+  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
   "",
-  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE' or 'FILE DIR'."),
-  N_("If --from-file or --to-file is given, there are no restrictions on FILE(s)."),
+  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("--speed-large-files  Assume large files and many scattered small changes."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  "",
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or `DIR FILE...' or 'FILE... DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
   N_("If a FILE is '-', read standard input."),
   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
   0
@@ -994,32 +932,24 @@ usage (void)
   char const * const *p;
 
   printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
-  printf ("%s\n\n", _("Compare FILES line by line."));
-
-  fputs (_("\
-Mandatory arguments to long options are mandatory for short options too.\n\
-"), stdout);
 
   for (p = option_help_msgid;  *p;  p++)
     {
       if (!**p)
-        putchar ('\n');
+	putchar ('\n');
       else
-        {
-          char const *msg = _(*p);
-          char const *nl;
-          while ((nl = strchr (msg, '\n')))
-            {
-              int msglen = nl + 1 - msg;
-              /* This assertion is solely to avoid a warning from
-                 gcc's -Wformat-overflow=.  */
-              assert (msglen < 4096);
-              printf ("  %.*s", msglen, msg);
-              msg = nl + 1;
-            }
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
 
-          printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
-        }
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
     }
   emit_bug_reporting_address ();
 }
@@ -1029,7 +959,7 @@ Mandatory arguments to long options are
 static void
 specify_value (char const **var, char const *value, char const *option)
 {
-  if (*var && ! STREQ (*var, value))
+  if (*var && strcmp (*var, value) != 0)
     {
       error (0, 0, _("conflicting %s option value '%s'"), option, value);
       try_help (NULL, NULL);
@@ -1044,25 +974,10 @@ specify_style (enum output_style style)
   if (output_style != style)
     {
       if (output_style != OUTPUT_UNSPECIFIED)
-        try_help ("conflicting output style options", NULL);
+	try_help ("conflicting output style options", NULL);
       output_style = style;
     }
 }
-
-/* Set the color mode.  */
-static void
-specify_colors_style (char const *value)
-{
-  if (value == NULL || STREQ (value, "auto"))
-    colors_style = AUTO;
-  else if (STREQ (value, "always"))
-    colors_style = ALWAYS;
-  else if (STREQ (value, "never"))
-    colors_style = NEVER;
-  else
-    try_help ("invalid color '%s'", value);
-}
-
 
 /* Set the last-modified time of *ST to be the current time.  */
 
@@ -1093,8 +1008,8 @@ set_mtime_to_now (struct stat *st)
 
 static int
 compare_files (struct comparison const *parent,
-               char const *name0,
-               char const *name1)
+	       char const *name0,
+	       char const *name1)
 {
   struct comparison cmp;
 #define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
@@ -1109,8 +1024,8 @@ compare_files (struct comparison const *
      If so, just print a message to that effect.  */
 
   if (! ((name0 && name1)
-         || (unidirectional_new_file && name1)
-         || new_file))
+	 || (unidirectional_new_file && name1)
+	 || new_file))
     {
       char const *name = name0 ? name0 : name1;
       char const *dir = parent->file[!name0].name;
@@ -1119,7 +1034,7 @@ compare_files (struct comparison const *
       message ("Only in %s: %s\n", dir, name);
 
       /* Return EXIT_FAILURE so that diff_dirs will return
-         EXIT_FAILURE ("some files differ").  */
+	 EXIT_FAILURE ("some files differ").  */
       return EXIT_FAILURE;
     }
 
@@ -1153,9 +1068,9 @@ compare_files (struct comparison const *
   else
     {
       cmp.file[0].name = free0
-        = file_name_concat (parent->file[0].name, name0, NULL);
+	= dir_file_pathname (parent->file[0].name, name0);
       cmp.file[1].name = free1
-        = file_name_concat (parent->file[1].name, name1, NULL);
+	= dir_file_pathname (parent->file[1].name, name1);
     }
 
   /* Stat the files.  */
@@ -1163,42 +1078,39 @@ compare_files (struct comparison const *
   for (f = 0; f < 2; f++)
     {
       if (cmp.file[f].desc != NONEXISTENT)
-        {
-          if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
-            {
-              cmp.file[f].desc = cmp.file[0].desc;
-              cmp.file[f].stat = cmp.file[0].stat;
-            }
-          else if (STREQ (cmp.file[f].name, "-"))
-            {
-              cmp.file[f].desc = STDIN_FILENO;
-              if (binary && ! isatty (STDIN_FILENO))
-                set_binary_mode (STDIN_FILENO, O_BINARY);
-              if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
-                cmp.file[f].desc = ERRNO_ENCODE (errno);
-              else
-                {
-                  if (S_ISREG (cmp.file[f].stat.st_mode))
-                    {
-                      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
-                      if (pos < 0)
-                        cmp.file[f].desc = ERRNO_ENCODE (errno);
-                      else
-                        cmp.file[f].stat.st_size =
-                          MAX (0, cmp.file[f].stat.st_size - pos);
-                    }
-
-                  /* POSIX 1003.1-2001 requires current time for
-                     stdin.  */
-                  set_mtime_to_now (&cmp.file[f].stat);
-                }
-            }
-          else if ((no_dereference_symlinks
-                    ? lstat (cmp.file[f].name, &cmp.file[f].stat)
-                    : stat (cmp.file[f].name, &cmp.file[f].stat))
-                   != 0)
-            cmp.file[f].desc = ERRNO_ENCODE (errno);
-        }
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
+		xfreopen (NULL, "rb", stdin);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
     }
 
   /* Mark files as nonexistent as needed for -N and -P, if they are
@@ -1208,58 +1120,53 @@ compare_files (struct comparison const *
      exist.  */
   for (f = 0; f < 2; f++)
     if ((new_file || (f == 0 && unidirectional_new_file))
-        && (cmp.file[f].desc == UNOPENED
-            ? (S_ISREG (cmp.file[f].stat.st_mode)
-               && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
-               && cmp.file[f].stat.st_size == 0)
-            : ((cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
-                || cmp.file[f].desc == ERRNO_ENCODE (EBADF))
-               && ! parent
-               && (cmp.file[1 - f].desc == UNOPENED
-                   || cmp.file[1 - f].desc == STDIN_FILENO))))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+	       && ! parent
+	       && cmp.file[1 - f].desc == UNOPENED)))
       cmp.file[f].desc = NONEXISTENT;
 
   for (f = 0; f < 2; f++)
     if (cmp.file[f].desc == NONEXISTENT)
       {
-        memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
-        cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
       }
 
   for (f = 0; f < 2; f++)
     {
       int e = ERRNO_DECODE (cmp.file[f].desc);
       if (0 <= e)
-        {
-          errno = e;
-          perror_with_name (cmp.file[f].name);
-          status = EXIT_TROUBLE;
-        }
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
     }
 
   if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
     {
       /* If one is a directory, and it was specified in the command line,
-         use the file in that dir with the other file's basename.  */
+	 use the file in that dir with the other file's basename.  */
 
       int fnm_arg = DIR_P (0);
       int dir_arg = 1 - fnm_arg;
       char const *fnm = cmp.file[fnm_arg].name;
       char const *dir = cmp.file[dir_arg].name;
       char const *filename = cmp.file[dir_arg].name = free0
-        = find_dir_file_pathname (dir, last_component (fnm));
+	= dir_file_pathname (dir, last_component (fnm));
 
       if (STREQ (fnm, "-"))
-        fatal ("cannot compare '-' to a directory");
+	fatal ("cannot compare '-' to a directory");
 
-      if ((no_dereference_symlinks
-           ? lstat (filename, &cmp.file[dir_arg].stat)
-           : stat (filename, &cmp.file[dir_arg].stat))
-          != 0)
-        {
-          perror_with_name (filename);
-          status = EXIT_TROUBLE;
-        }
+      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
     }
 
   if (status != EXIT_SUCCESS)
@@ -1267,145 +1174,91 @@ compare_files (struct comparison const *
       /* One of the files should exist but does not.  */
     }
   else if (cmp.file[0].desc == NONEXISTENT
-           && cmp.file[1].desc == NONEXISTENT)
+	   && cmp.file[1].desc == NONEXISTENT)
     {
       /* Neither file "exists", so there's nothing to compare.  */
     }
   else if ((same_files
-            = (cmp.file[0].desc != NONEXISTENT
-               && cmp.file[1].desc != NONEXISTENT
-               && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
-               && same_file_attributes (&cmp.file[0].stat,
-                                        &cmp.file[1].stat)))
-           && no_diff_means_no_output)
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
     {
       /* The two named files are actually the same physical file.
-         We know they are identical without actually reading them.  */
+	 We know they are identical without actually reading them.  */
     }
   else if (DIR_P (0) & DIR_P (1))
     {
       if (output_style == OUTPUT_IFDEF)
-        fatal ("-D option not supported with directories");
+	fatal ("-D option not supported with directories");
 
       /* If both are directories, compare the files in them.  */
 
       if (parent && !recursive)
-        {
-          /* But don't compare dir contents one level down
-             unless -r was specified.
-             See POSIX 1003.1-2001 for this format.  */
-          message ("Common subdirectories: %s and %s\n",
-                   cmp.file[0].name, cmp.file[1].name);
-        }
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
       else
-        status = diff_dirs (&cmp, compare_files);
+	status = diff_dirs (&cmp, compare_files);
     }
   else if ((DIR_P (0) | DIR_P (1))
-           || (parent
-               && !((S_ISREG (cmp.file[0].stat.st_mode)
-                     || S_ISLNK (cmp.file[0].stat.st_mode))
-                    && (S_ISREG (cmp.file[1].stat.st_mode)
-                        || S_ISLNK  (cmp.file[1].stat.st_mode)))))
+	   || (parent
+	       && (! S_ISREG (cmp.file[0].stat.st_mode)
+		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
     {
       if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
-        {
-          /* We have a subdirectory that exists only in one directory.  */
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
 
-          if ((DIR_P (0) | DIR_P (1))
-              && recursive
-              && (new_file
-                  || (unidirectional_new_file
-                      && cmp.file[0].desc == NONEXISTENT)))
-            status = diff_dirs (&cmp, compare_files);
-          else
-            {
-              char const *dir;
-
-              /* PARENT must be non-NULL here.  */
-              assert (parent);
-              dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
-
-              /* See POSIX 1003.1-2001 for this format.  */
-              message ("Only in %s: %s\n", dir, name0);
-
-              status = EXIT_FAILURE;
-            }
-        }
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
       else
-        {
-          /* We have two files that are not to be compared.  */
+	{
+	  /* We have two files that are not to be compared.  */
 
-          /* See POSIX 1003.1-2001 for this format.  */
-          message5 ("File %s is a %s while file %s is a %s\n",
-                    file_label[0] ? file_label[0] : cmp.file[0].name,
-                    file_type (&cmp.file[0].stat),
-                    file_label[1] ? file_label[1] : cmp.file[1].name,
-                    file_type (&cmp.file[1].stat));
-
-          /* This is a difference.  */
-          status = EXIT_FAILURE;
-        }
-    }
-  else if (S_ISLNK (cmp.file[0].stat.st_mode)
-           || S_ISLNK (cmp.file[1].stat.st_mode))
-    {
-      /* We get here only if we use lstat(), not stat().  */
-      assert (no_dereference_symlinks);
-
-      if (S_ISLNK (cmp.file[0].stat.st_mode)
-          && S_ISLNK (cmp.file[1].stat.st_mode))
-        {
-          /* Compare the values of the symbolic links.  */
-          char *link_value[2] = { NULL, NULL };
-
-          for (f = 0; f < 2; f++)
-            {
-              link_value[f] = xreadlink (cmp.file[f].name);
-              if (link_value[f] == NULL)
-                {
-                  perror_with_name (cmp.file[f].name);
-                  status = EXIT_TROUBLE;
-                  break;
-                }
-            }
-          if (status == EXIT_SUCCESS)
-            {
-              if ( ! STREQ (link_value[0], link_value[1]))
-                {
-                  message ("Symbolic links %s and %s differ\n",
-                           cmp.file[0].name, cmp.file[1].name);
-                  /* This is a difference.  */
-                  status = EXIT_FAILURE;
-                }
-            }
-          for (f = 0; f < 2; f++)
-            free (link_value[f]);
-        }
-      else
-        {
-          /* We have two files that are not to be compared, because
-             one of them is a symbolic link and the other one is not.  */
-
-          message5 ("File %s is a %s while file %s is a %s\n",
-                    file_label[0] ? file_label[0] : cmp.file[0].name,
-                    file_type (&cmp.file[0].stat),
-                    file_label[1] ? file_label[1] : cmp.file[1].name,
-                    file_type (&cmp.file[1].stat));
-
-          /* This is a difference.  */
-          status = EXIT_FAILURE;
-        }
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
     }
   else if (files_can_be_treated_as_binary
-           && S_ISREG (cmp.file[0].stat.st_mode)
-           && S_ISREG (cmp.file[1].stat.st_mode)
-           && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size
-           && 0 < cmp.file[0].stat.st_size
-           && 0 < cmp.file[1].stat.st_size)
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
     {
       message ("Files %s and %s differ\n",
-               file_label[0] ? file_label[0] : cmp.file[0].name,
-               file_label[1] ? file_label[1] : cmp.file[1].name);
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
       status = EXIT_FAILURE;
     }
   else
@@ -1417,40 +1270,40 @@ compare_files (struct comparison const *
       int oflags = O_RDONLY | (binary ? O_BINARY : 0);
 
       if (cmp.file[0].desc == UNOPENED)
-        if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
-          {
-            perror_with_name (cmp.file[0].name);
-            status = EXIT_TROUBLE;
-          }
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
       if (cmp.file[1].desc == UNOPENED)
-        {
-          if (same_files)
-            cmp.file[1].desc = cmp.file[0].desc;
-          else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
-            {
-              perror_with_name (cmp.file[1].name);
-              status = EXIT_TROUBLE;
-            }
-        }
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
 
       /* Compare the files, if no error was found.  */
 
       if (status == EXIT_SUCCESS)
-        status = diff_2_files (&cmp);
+	status = diff_2_files (&cmp);
 
       /* Close the file descriptors.  */
 
       if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
-        {
-          perror_with_name (cmp.file[0].name);
-          status = EXIT_TROUBLE;
-        }
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
       if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
-          && close (cmp.file[1].desc) != 0)
-        {
-          perror_with_name (cmp.file[1].name);
-          status = EXIT_TROUBLE;
-        }
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
     }
 
   /* Now the comparison has been done, if no error prevented it,
@@ -1459,16 +1312,16 @@ compare_files (struct comparison const *
   if (status == EXIT_SUCCESS)
     {
       if (report_identical_files && !DIR_P (0))
-        message ("Files %s and %s are identical\n",
-                 file_label[0] ? file_label[0] : cmp.file[0].name,
-                 file_label[1] ? file_label[1] : cmp.file[1].name);
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
     }
   else
     {
       /* Flush stdout so that the user sees differences immediately.
-         This can hurt performance, unfortunately.  */
+	 This can hurt performance, unfortunately.  */
       if (fflush (stdout) != 0)
-        pfatal_with_name (_("standard output"));
+	pfatal_with_name (_("standard output"));
     }
 
   free (free0);
diff -pru diffutils-3.0/dir.c diffutils-3.0-patch/dir.c
--- diffutils-3.0/dir.c	2020-05-30 16:24:16.379936000 -0700
+++ diffutils-3.0-patch/dir.c	2020-05-30 15:52:03.060069000 -0700
@@ -1,7 +1,7 @@
 /* Read, sort and compare two directories.  Used for GNU DIFF.
 
    Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
-   2009-2013, 2015-2020 Free Software Foundation, Inc.
+   2009-2010 Free Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -21,7 +21,6 @@
 #include "diff.h"
 #include <error.h>
 #include <exclude.h>
-#include <filenamecat.h>
 #include <setjmp.h>
 #include <xalloc.h>
 
@@ -45,6 +44,7 @@ static bool locale_specific_sorting;
 static jmp_buf failed_locale_specific_sorting;
 
 static bool dir_loop (struct comparison const *, int);
+static int compare_names_for_qsort (void const *, void const *);
 
 
 /* Read a directory and get its vector of names.  */
@@ -75,7 +75,7 @@ dir_read (struct file_data const *dir, s
       /* Open the directory and check for errors.  */
       register DIR *reading = opendir (dir->name);
       if (!reading)
-        return false;
+	return false;
 
       /* Initialize the table of filenames.  */
 
@@ -84,44 +84,44 @@ dir_read (struct file_data const *dir, s
       dirdata->data = data = xmalloc (data_alloc);
 
       /* Read the directory entries, and insert the subfiles
-         into the 'data' table.  */
+	 into the `data' table.  */
 
       while ((errno = 0, (next = readdir (reading)) != 0))
-        {
-          char *d_name = next->d_name;
-          size_t d_size = _D_EXACT_NAMLEN (next) + 1;
-
-          /* Ignore "." and "..".  */
-          if (d_name[0] == '.'
-              && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
-            continue;
-
-          if (excluded_file_name (excluded, d_name))
-            continue;
-
-          while (data_alloc < data_used + d_size)
-            {
-              if (PTRDIFF_MAX / 2 <= data_alloc)
-                xalloc_die ();
-              dirdata->data = data = xrealloc (data, data_alloc *= 2);
-            }
-
-          memcpy (data + data_used, d_name, d_size);
-          data_used += d_size;
-          nnames++;
-        }
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
       if (errno)
-        {
-          int e = errno;
-          closedir (reading);
-          errno = e;
-          return false;
-        }
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
 #if CLOSEDIR_VOID
       closedir (reading);
 #else
       if (closedir (reading) != 0)
-        return false;
+	return false;
 #endif
     }
 
@@ -139,27 +139,6 @@ dir_read (struct file_data const *dir, s
   return true;
 }
 
-/* Compare strings in a locale-specific way, returning a value
-   compatible with strcmp.  */
-
-static int
-compare_collated (char const *name1, char const *name2)
-{
-  int r;
-  errno = 0;
-  if (ignore_file_name_case)
-    r = strcasecoll (name1, name2);
-  else
-    r = strcoll (name1, name2);
-  if (errno)
-    {
-      error (0, errno, _("cannot compare file names '%s' and '%s'"),
-             name1, name2);
-      longjmp (failed_locale_specific_sorting, 1);
-    }
-  return r;
-}
-
 /* Compare file names, returning a value compatible with strcmp.  */
 
 static int
@@ -167,30 +146,34 @@ compare_names (char const *name1, char c
 {
   if (locale_specific_sorting)
     {
-      int diff = compare_collated (name1, name2);
-      if (diff || ignore_file_name_case)
-        return diff;
+      int r;
+      errno = 0;
+      if (ignore_file_name_case)
+	r = strcasecoll (name1, name2);
+      else
+	r = strcoll (name1, name2);
+      if (errno)
+	{
+	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+		 name1, name2);
+	  longjmp (failed_locale_specific_sorting, 1);
+	}
+      return r;
     }
-  return file_name_cmp (name1, name2);
+
+  return (ignore_file_name_case
+	  ? strcasecmp (name1, name2)
+	  : file_name_cmp (name1, name2));
 }
 
-/* Compare names FILE1 and FILE2 when sorting a directory.
-   Prefer filtered comparison, breaking ties with file_name_cmp.  */
+/* A wrapper for compare_names suitable as an argument for qsort.  */
 
 static int
 compare_names_for_qsort (void const *file1, void const *file2)
 {
   char const *const *f1 = file1;
   char const *const *f2 = file2;
-  char const *name1 = *f1;
-  char const *name2 = *f2;
-  if (locale_specific_sorting)
-    {
-      int diff = compare_collated (name1, name2);
-      if (diff)
-        return diff;
-    }
-  return file_name_cmp (name1, name2);
+  return compare_names (*f1, *f2);
 }
 
 /* Compare the contents of two directories named in CMP.
@@ -212,8 +195,8 @@ compare_names_for_qsort (void const *fil
 
 int
 diff_dirs (struct comparison const *cmp,
-           int (*handle_file) (struct comparison const *,
-                               char const *, char const *))
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
 {
   struct dirdata dirdata[2];
   int volatile val = EXIT_SUCCESS;
@@ -223,7 +206,7 @@ diff_dirs (struct comparison const *cmp,
       && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
     {
       error (0, 0, _("%s: recursive directory loop"),
-             cmp->file[cmp->file[0].desc == -1].name);
+	     cmp->file[cmp->file[0].desc == -1].name);
       return EXIT_TROUBLE;
     }
 
@@ -231,8 +214,8 @@ diff_dirs (struct comparison const *cmp,
   for (i = 0; i < 2; i++)
     if (! dir_read (&cmp->file[i], &dirdata[i]))
       {
-        perror_with_name (cmp->file[i].name);
-        val = EXIT_TROUBLE;
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
       }
 
   if (val == EXIT_SUCCESS)
@@ -244,73 +227,38 @@ diff_dirs (struct comparison const *cmp,
       /* Use locale-specific sorting if possible, else native byte order.  */
       locale_specific_sorting = true;
       if (setjmp (failed_locale_specific_sorting))
-        locale_specific_sorting = false;
+	locale_specific_sorting = false;
 
       /* Sort the directories.  */
       for (i = 0; i < 2; i++)
-        qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
-               compare_names_for_qsort);
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
 
       /* If '-S name' was given, and this is the topmost level of comparison,
-         ignore all file names less than the specified starting name.  */
+	 ignore all file names less than the specified starting name.  */
 
       if (starting_file && ! cmp->parent)
-        {
-          while (*names[0] && compare_names (*names[0], starting_file) < 0)
-            names[0]++;
-          while (*names[1] && compare_names (*names[1], starting_file) < 0)
-            names[1]++;
-        }
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
 
       /* Loop while files remain in one or both dirs.  */
       while (*names[0] || *names[1])
-        {
-          /* Compare next name in dir 0 with next name in dir 1.
-             At the end of a dir,
-             pretend the "next name" in that dir is very large.  */
-          int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
-                           : compare_names (*names[0], *names[1]));
-
-          /* Prefer a file_name_cmp match if available.  This algorithm is
-             O(N**2), where N is the number of names in a directory
-             that compare_names says are all equal, but in practice N
-             is so small it's not worth tuning.  */
-          if (nameorder == 0 && ignore_file_name_case)
-            {
-              int raw_order = file_name_cmp (*names[0], *names[1]);
-              if (raw_order != 0)
-                {
-                  int greater_side = raw_order < 0;
-                  int lesser_side = 1 - greater_side;
-                  char const **lesser = names[lesser_side];
-                  char const *greater_name = *names[greater_side];
-                  char const **p;
-
-                  for (p = lesser + 1;
-                       *p && compare_names (*p, greater_name) == 0;
-                       p++)
-                    {
-                      int c = file_name_cmp (*p, greater_name);
-                      if (0 <= c)
-                        {
-                          if (c == 0)
-                            {
-                              memmove (lesser + 1, lesser,
-                                       (char *) p - (char *) lesser);
-                              *lesser = greater_name;
-                            }
-                          break;
-                        }
-                    }
-                }
-            }
-
-          int v1 = (*handle_file) (cmp,
-                                   0 < nameorder ? 0 : *names[0]++,
-                                   nameorder < 0 ? 0 : *names[1]++);
-          if (val < v1)
-            val = v1;
-        }
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
     }
 
   for (i = 0; i < 2; i++)
@@ -324,7 +272,7 @@ diff_dirs (struct comparison const *cmp,
 
 /* Return nonzero if CMP is looping recursively in argument I.  */
 
-static bool _GL_ATTRIBUTE_PURE
+static bool
 dir_loop (struct comparison const *cmp, int i)
 {
   struct comparison const *p = cmp;
@@ -333,53 +281,3 @@ dir_loop (struct comparison const *cmp,
       return true;
   return false;
 }
-
-/* Find a matching filename in a directory.  */
-
-char *
-find_dir_file_pathname (char const *dir, char const *file)
-{
-  /* The 'IF_LINT (volatile)' works around what appears to be a bug in
-     gcc 4.8.0 20120825; see
-     <http://lists.gnu.org/archive/html/bug-diffutils/2012-08/msg00007.html>.
-     */
-  char const * IF_LINT (volatile) match = file;
-
-  char *val;
-  struct dirdata dirdata;
-  dirdata.names = NULL;
-  dirdata.data = NULL;
-
-  if (ignore_file_name_case)
-    {
-      struct file_data filedata;
-      filedata.name = dir;
-      filedata.desc = 0;
-
-      if (dir_read (&filedata, &dirdata))
-        {
-          locale_specific_sorting = true;
-          if (setjmp (failed_locale_specific_sorting))
-            match = file; /* longjmp may mess up MATCH.  */
-          else
-            {
-              for (char const **p = dirdata.names; *p; p++)
-                if (compare_names (*p, file) == 0)
-                  {
-                    if (file_name_cmp (*p, file) == 0)
-                      {
-                        match = *p;
-                        break;
-                      }
-                    if (match == file)
-                      match = *p;
-                  }
-            }
-        }
-    }
-
-  val = file_name_concat (dir, match, NULL);
-  free (dirdata.names);
-  free (dirdata.data);
-  return val;
-}
diff -pru diffutils-3.0/ed.c diffutils-3.0-patch/ed.c
--- diffutils-3.0/ed.c	2020-05-30 16:24:16.382932000 -0700
+++ diffutils-3.0-patch/ed.c	2020-05-30 15:52:03.062068000 -0700
@@ -1,7 +1,7 @@
 /* Output routines for ed-script format.
 
-   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2013,
-   2015-2020 Free Software Foundation, Inc.
+   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -63,26 +63,26 @@ print_ed_hunk (struct change *hunk)
       bool insert_mode = true;
 
       for (i = f1; i <= l1; i++)
-        {
-          if (!insert_mode)
-            {
-              fputs ("a\n", outfile);
-              insert_mode = true;
-            }
-          if (files[1].linbuf[i][0] == '.' && files[1].linbuf[i][1] == '\n')
-            {
-              /* The file's line is just a dot, and it would exit
-                 insert mode.  Precede the dot with another dot, exit
-                 insert mode and remove the extra dot.  */
-              fputs ("..\n.\ns/.//\n", outfile);
-              insert_mode = false;
-            }
-          else
-            print_1_line ("", &files[1].linbuf[i]);
-        }
+	{
+	  if (!insert_mode)
+	    {
+	      fputs ("a\n", outfile);
+	      insert_mode = true;
+	    }
+	  if (files[1].linbuf[i][0] == '.' && files[1].linbuf[i][1] == '\n')
+	    {
+	      /* The file's line is just a dot, and it would exit
+		 insert mode.  Precede the dot with another dot, exit
+		 insert mode and remove the extra dot.  */
+	      fputs ("..\n.\ns/.//\n", outfile);
+	      insert_mode = false;
+	    }
+	  else
+	    print_1_line ("", &files[1].linbuf[i]);
+	}
 
       if (insert_mode)
-        fputs (".\n", outfile);
+	fputs (".\n", outfile);
     }
 }
 
@@ -144,7 +144,7 @@ static void
 print_rcs_hunk (struct change *hunk)
 {
   lin i, f0, l0, f1, l1;
-  printint tf0, tl0, tf1, tl1;
+  long int tf0, tl0, tf1, tl1;
 
   /* Determine range of line numbers involved in each file.  */
   enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
@@ -158,20 +158,18 @@ print_rcs_hunk (struct change *hunk)
   if (changes & OLD)
     {
       /* For deletion, print just the starting line number from file 0
-         and the number of lines deleted.  */
-      fprintf (outfile, "d%"pI"d %"pI"d\n", tf0,
-               tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
+	 and the number of lines deleted.  */
+      fprintf (outfile, "d%ld %ld\n", tf0, tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
     }
 
   if (changes & NEW)
     {
       /* Take last-line-number from file 0 and # lines from file 1.  */
       translate_range (&files[1], f1, l1, &tf1, &tl1);
-      fprintf (outfile, "a%"pI"d %"pI"d\n", tl0,
-               tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
+      fprintf (outfile, "a%ld %ld\n", tl0, tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
 
       /* Print the inserted lines.  */
       for (i = f1; i <= l1; i++)
-        print_1_line ("", &files[1].linbuf[i]);
+	print_1_line ("", &files[1].linbuf[i]);
     }
 }
diff -pru diffutils-3.0/ifdef.c diffutils-3.0-patch/ifdef.c
--- diffutils-3.0/ifdef.c	2020-05-30 16:24:16.384930000 -0700
+++ diffutils-3.0-patch/ifdef.c	2020-05-30 15:52:03.065064000 -0700
@@ -1,7 +1,7 @@
 /* #ifdef-format output routines for GNU DIFF.
 
-   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2013, 2015-2020
-   Free Software Foundation, Inc.
+   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2010 Free
+   Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -31,10 +31,10 @@ struct group
 };
 
 static char const *format_group (FILE *, char const *, char,
-                                 struct group const *);
+				 struct group const *);
 static char const *do_printf_spec (FILE *, char const *,
-                                   struct file_data const *, lin,
-                                   struct group const *);
+				   struct file_data const *, lin,
+				   struct group const *);
 static char const *scan_char_literal (char const *, char *);
 static lin groups_letter_value (struct group const *, char);
 static void format_ifdef (char const *, lin, lin, lin, lin);
@@ -56,8 +56,8 @@ print_ifdef_script (struct change *scrip
     {
       begin_output ();
       format_ifdef (group_format[UNCHANGED],
-                    next_line0, files[0].valid_lines,
-                    next_line1, files[1].valid_lines);
+		    next_line0, files[0].valid_lines,
+		    next_line1, files[1].valid_lines);
     }
 }
 
@@ -80,15 +80,15 @@ print_ifdef_hunk (struct change *hunk)
   /* Print lines up to this change.  */
   if (next_line0 < first0 || next_line1 < first1)
     format_ifdef (group_format[UNCHANGED],
-                  next_line0, first0,
-                  next_line1, first1);
+		  next_line0, first0,
+		  next_line1, first1);
 
   /* Print this change.  */
   next_line0 = last0 + 1;
   next_line1 = last1 + 1;
   format_ifdef (group_format[changes],
-                first0, next_line0,
-                first1, next_line1);
+		first0, next_line0,
+		first1, next_line1);
 }
 
 /* Print a set of lines according to FORMAT.
@@ -117,7 +117,7 @@ format_ifdef (char const *format, lin be
 
 static char const *
 format_group (register FILE *out, char const *format, char endchar,
-              struct group const *groups)
+	      struct group const *groups)
 {
   register char c;
   register char const *f = format;
@@ -126,81 +126,81 @@ format_group (register FILE *out, char c
     {
       char const *f1 = ++f;
       if (c == '%')
-        switch ((c = *f++))
-          {
-          case '%':
-            break;
-
-          case '(':
-            /* Print if-then-else format e.g. '%(n=1?thenpart:elsepart)'.  */
-            {
-              int i;
-              intmax_t value[2];
-              FILE *thenout, *elseout;
-
-              for (i = 0; i < 2; i++)
-                {
-                  if (ISDIGIT (*f))
-                    {
-                      char *fend;
-                      errno = 0;
-                      value[i] = strtoimax (f, &fend, 10);
-                      if (errno)
-                        goto bad_format;
-                      f = fend;
-                    }
-                  else
-                    {
-                      value[i] = groups_letter_value (groups, *f);
-                      if (value[i] < 0)
-                        goto bad_format;
-                      f++;
-                    }
-                  if (*f++ != "=?"[i])
-                    goto bad_format;
-                }
-              if (value[0] == value[1])
-                thenout = out, elseout = 0;
-              else
-                thenout = 0, elseout = out;
-              f = format_group (thenout, f, ':', groups);
-              if (*f)
-                {
-                  f = format_group (elseout, f + 1, ')', groups);
-                  if (*f)
-                    f++;
-                }
-            }
-            continue;
-
-          case '<':
-            /* Print lines deleted from first file.  */
-            print_ifdef_lines (out, line_format[OLD], &groups[0]);
-            continue;
-
-          case '=':
-            /* Print common lines.  */
-            print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
-            continue;
-
-          case '>':
-            /* Print lines inserted from second file.  */
-            print_ifdef_lines (out, line_format[NEW], &groups[1]);
-            continue;
-
-          default:
-            f = do_printf_spec (out, f - 2, 0, 0, groups);
-            if (f)
-              continue;
-            /* Fall through. */
-          bad_format:
-            c = '%';
-            f = f1;
-            break;
-          }
+	switch ((c = *f++))
+	  {
+	  case '%':
+	    break;
+
+	  case '(':
+	    /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
+	    {
+	      int i;
+	      uintmax_t value[2];
+	      FILE *thenout, *elseout;
+
+	      for (i = 0; i < 2; i++)
+		{
+		  if (ISDIGIT (*f))
+		    {
+		      char *fend;
+		      errno = 0;
+		      value[i] = strtoumax (f, &fend, 10);
+		      if (errno)
+			goto bad_format;
+		      f = fend;
+		    }
+		  else
+		    {
+		      value[i] = groups_letter_value (groups, *f);
+		      if (value[i] == -1)
+			goto bad_format;
+		      f++;
+		    }
+		  if (*f++ != "=?"[i])
+		    goto bad_format;
+		}
+	      if (value[0] == value[1])
+		thenout = out, elseout = 0;
+	      else
+		thenout = 0, elseout = out;
+	      f = format_group (thenout, f, ':', groups);
+	      if (*f)
+		{
+		  f = format_group (elseout, f + 1, ')', groups);
+		  if (*f)
+		    f++;
+		}
+	    }
+	    continue;
+
+	  case '<':
+	    /* Print lines deleted from first file.  */
+	    print_ifdef_lines (out, line_format[OLD], &groups[0]);
+	    continue;
+
+	  case '=':
+	    /* Print common lines.  */
+	    print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
+	    continue;
+
+	  case '>':
+	    /* Print lines inserted from second file.  */
+	    print_ifdef_lines (out, line_format[NEW], &groups[1]);
+	    continue;
+
+	  default:
+	    f = do_printf_spec (out, f - 2, 0, 0, groups);
+	    if (f)
+	      continue;
+	    /* Fall through. */
+	  bad_format:
+	    c = '%';
+	    f = f1;
+	    break;
+	  }
 
       if (out)
-        putc (c, out);
+	putc (c, out);
     }
 
   return f;
@@ -235,7 +235,7 @@ groups_letter_value (struct group const
    But do nothing if OUT is zero.  */
 static void
 print_ifdef_lines (register FILE *out, char const *format,
-                   struct group const *group)
+		   struct group const *group)
 {
   struct file_data const *file = group->file;
   char const * const *linbuf = file->linbuf;
@@ -248,18 +248,18 @@ print_ifdef_lines (register FILE *out, c
   if (!expand_tabs && format[0] == '%')
     {
       if (format[1] == 'l' && format[2] == '\n' && !format[3] && from < upto)
-        {
-          fwrite (linbuf[from], sizeof (char),
-                  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
-                  out);
-          return;
-        }
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
+		  out);
+	  return;
+	}
       if (format[1] == 'L' && !format[2])
-        {
-          fwrite (linbuf[from], sizeof (char),
-                  linbuf[upto] -  linbuf[from], out);
-          return;
-        }
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] -  linbuf[from], out);
+	  return;
+	}
     }
 
   for (;  from < upto;  from++)
@@ -268,43 +268,43 @@ print_ifdef_lines (register FILE *out, c
       register char const *f = format;
 
       while ((c = *f++) != 0)
-        {
-          char const *f1 = f;
-          if (c == '%')
-            switch ((c = *f++))
-              {
-              case '%':
-                break;
-
-              case 'l':
-                output_1_line (linbuf[from],
-                               (linbuf[from + 1]
-                                - (linbuf[from + 1][-1] == '\n')),
-                               0, 0);
-                continue;
-
-              case 'L':
-                output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
-                continue;
-
-              default:
-                f = do_printf_spec (out, f - 2, file, from, 0);
-                if (f)
-                  continue;
-                c = '%';
-                f = f1;
-                break;
-              }
+	{
+	  char const *f1 = f;
+	  if (c == '%')
+	    switch ((c = *f++))
+	      {
+	      case '%':
+		break;
+
+	      case 'l':
+		output_1_line (linbuf[from],
+			       (linbuf[from + 1]
+				- (linbuf[from + 1][-1] == '\n')),
+			       0, 0);
+		continue;
+
+	      case 'L':
+		output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
+		continue;
+
+	      default:
+		f = do_printf_spec (out, f - 2, file, from, 0);
+		if (f)
+		  continue;
+		c = '%';
+		f = f1;
+		break;
+	      }
 
-          putc (c, out);
-        }
+	  putc (c, out);
+	}
     }
 }
 
 static char const *
 do_printf_spec (FILE *out, char const *spec,
-                struct file_data const *file, lin n,
-                struct group const *groups)
+		struct file_data const *file, lin n,
+		struct group const *groups)
 {
   char const *f = spec;
   char c;
@@ -326,57 +326,56 @@ do_printf_spec (FILE *out, char const *s
     {
     case 'c':
       if (c1 != '\'')
-        return 0;
+	return 0;
       else
-        {
-          char value IF_LINT (= 0);
-          f = scan_char_literal (f, &value);
-          if (!f)
-            return 0;
-          if (out)
-            putc (value, out);
-        }
+	{
+	  char value IF_LINT (= 0);
+	  f = scan_char_literal (f, &value);
+	  if (!f)
+	    return 0;
+	  if (out)
+	    putc (value, out);
+	}
       break;
 
     case 'd': case 'o': case 'x': case 'X':
       {
-        lin value;
+	lin value;
 
-        if (file)
-          {
-            if (c1 != 'n')
-              return 0;
-            value = translate_line_number (file, n);
-          }
-        else
-          {
-            value = groups_letter_value (groups, c1);
-            if (value < 0)
-              return 0;
-          }
-
-        if (out)
-          {
-            /* For example, if the spec is "%3xn" and pI is "l", use the printf
-               format spec "%3lx".  Here the spec prefix is "%3".  */
-            printint print_value = value;
-            size_t spec_prefix_len = f - spec - 2;
-            size_t pI_len = sizeof pI - 1;
-#if 0
-            char format[spec_prefix_len + pI_len + 2];
+	if (file)
+	  {
+	    if (c1 != 'n')
+	      return 0;
+	    value = translate_line_number (file, n);
+	  }
+	else
+	  {
+	    value = groups_letter_value (groups, c1);
+	    if (value < 0)
+	      return 0;
+	  }
+
+	if (out)
+	  {
+	    /* For example, if the spec is "%3xn", use the printf
+	       format spec "%3lx".  Here the spec prefix is "%3".  */
+	    long int long_value = value;
+	    size_t spec_prefix_len = f - spec - 2;
+#if HAVE_C_VARARRAYS
+	    char format[spec_prefix_len + 3];
 #else
-            char *format = xmalloc (spec_prefix_len + pI_len + 2);
+	    char *format = xmalloc (spec_prefix_len + 3);
 #endif
-            char *p = format + spec_prefix_len + pI_len;
-            memcpy (format, spec, spec_prefix_len);
-            memcpy (format + spec_prefix_len, pI, pI_len);
-            *p++ = c;
-            *p = '\0';
-            fprintf (out, format, print_value);
+	    char *p = format + spec_prefix_len;
+	    memcpy (format, spec, spec_prefix_len);
+	    *p++ = 'l';
+	    *p++ = c;
+	    *p = '\0';
+	    fprintf (out, format, long_value);
 #if ! HAVE_C_VARARRAYS
-            free (format);
+	    free (format);
 #endif
-          }
+	  }
       }
       break;
 
@@ -403,27 +402,27 @@ scan_char_literal (char const *lit, char
     {
       case 0:
       case '\'':
-        return NULL;
+	return NULL;
 
       case '\\':
-        value = 0;
-        while ((c = *p++) != '\'')
-          {
-            unsigned int digit = c - '0';
-            if (8 <= digit)
-              return NULL;
-            value = 8 * value + digit;
-          }
-        digits = p - lit - 2;
-        if (! (1 <= digits && digits <= 3))
-          return NULL;
-        break;
+	value = 0;
+	while ((c = *p++) != '\'')
+	  {
+	    unsigned int digit = c - '0';
+	    if (8 <= digit)
+	      return NULL;
+	    value = 8 * value + digit;
+	  }
+	digits = p - lit - 2;
+	if (! (1 <= digits && digits <= 3))
+	  return NULL;
+	break;
 
       default:
-        value = c;
-        if (*p++ != '\'')
-          return NULL;
-        break;
+	value = c;
+	if (*p++ != '\'')
+	  return NULL;
+	break;
     }
 
   *valptr = value;
diff -pru diffutils-3.0/io.c diffutils-3.0-patch/io.c
--- diffutils-3.0/io.c	2020-05-30 16:24:16.386928000 -0700
+++ diffutils-3.0-patch/io.c	2020-05-30 15:52:03.067063000 -0700
@@ -1,7 +1,7 @@
 /* File I/O for GNU DIFF.
 
-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
-   2015-2020 Free Software Foundation, Inc.
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -19,7 +19,6 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 #include "diff.h"
-#include <binary-io.h>
 #include <cmpbuf.h>
 #include <file-type.h>
 #include <xalloc.h>
@@ -58,10 +57,10 @@ static size_t nbuckets;
    The number of an equivalence class is its index in this array.  */
 static struct equivclass *equivs;
 
-/* Index of first free element in the array 'equivs'.  */
+/* Index of first free element in the array `equivs'.  */
 static lin equivs_index;
 
-/* Number of elements allocated in the array 'equivs'.  */
+/* Number of elements allocated in the array `equivs'.  */
 static lin equivs_alloc;
 
 /* Read a block of data into a file buffer, checking for EOF and error.  */
@@ -72,9 +71,9 @@ file_block_read (struct file_data *curre
   if (size && ! current->eof)
     {
       size_t s = block_read (current->desc,
-                             FILE_BUFFER (current) + current->buffered, size);
+			     FILE_BUFFER (current) + current->buffered, size);
       if (s == SIZE_MAX)
-        pfatal_with_name (current->name);
+	pfatal_with_name (current->name);
       current->buffered += s;
       current->eof = s < size;
     }
@@ -104,40 +103,20 @@ sip (struct file_data *current, bool ski
   else
     {
       current->bufsize = buffer_lcm (sizeof (word),
-                                     STAT_BLOCKSIZE (current->stat),
-                                     PTRDIFF_MAX - 2 * sizeof (word));
+				     STAT_BLOCKSIZE (current->stat),
+				     PTRDIFF_MAX - 2 * sizeof (word));
       current->buffer = xmalloc (current->bufsize);
 
-#ifdef __KLIBC__
-      /* Skip test if seek is not possible */
-      skip_test = skip_test
-                  || (lseek (current->desc, 0, SEEK_CUR) < 0
-                      && errno == ESPIPE);
-#endif
-
       if (! skip_test)
-        {
-          /* Check first part of file to see if it's a binary file.  */
+	{
+	  /* Check first part of file to see if it's a binary file.  */
 
-          int prev_mode = set_binary_mode (current->desc, O_BINARY);
-          off_t buffered;
-          file_block_read (current, current->bufsize);
-          buffered = current->buffered;
-
-          if (prev_mode != O_BINARY)
-            {
-              /* Revert to text mode and seek back to the start to reread
-                 the file.  Use relative seek, since file descriptors
-                 like stdin might not start at offset zero.  */
-              if (lseek (current->desc, - buffered, SEEK_CUR) < 0)
-                pfatal_with_name (current->name);
-              set_binary_mode (current->desc, prev_mode);
-              current->buffered = 0;
-              current->eof = false;
-            }
+	  /* FIXME: if O_BINARY, this should revert to text mode
+	     if the file is not binary.  */
 
-          return binary_file_p (current->buffer, buffered);
-        }
+	  file_block_read (current, current->bufsize);
+	  return binary_file_p (current->buffer, current->buffered);
+	}
     }
 
   current->buffered = 0;
@@ -163,30 +142,30 @@ slurp (struct file_data *current)
       /* It's a regular file; slurp in the rest all at once.  */
 
       /* Get the size out of the stat block.
-         Allocate just enough room for appended newline plus word sentinel,
-         plus word-alignment since we want the buffer word-aligned.  */
+	 Allocate just enough room for appended newline plus word sentinel,
+	 plus word-alignment since we want the buffer word-aligned.  */
       size_t file_size = current->stat.st_size;
       cc = file_size + 2 * sizeof (word) - file_size % sizeof (word);
       if (file_size != current->stat.st_size || cc < file_size
-          || PTRDIFF_MAX <= cc)
-        xalloc_die ();
+	  || PTRDIFF_MAX <= cc)
+	xalloc_die ();
 
       if (current->bufsize < cc)
-        {
-          current->bufsize = cc;
-          current->buffer = xrealloc (current->buffer, cc);
-        }
+	{
+	  current->bufsize = cc;
+	  current->buffer = xrealloc (current->buffer, cc);
+	}
 
       /* Try to read at least 1 more byte than the size indicates, to
-         detect whether the file is growing.  This is a nicety for
-         users who run 'diff' on files while they are changing.  */
+	 detect whether the file is growing.  This is a nicety for
+	 users who run 'diff' on files while they are changing.  */
 
       if (current->buffered <= file_size)
-        {
-          file_block_read (current, file_size + 1 - current->buffered);
-          if (current->buffered <= file_size)
-            return;
-        }
+	{
+	  file_block_read (current, file_size + 1 - current->buffered);
+	  if (current->buffered <= file_size)
+	    return;
+	}
     }
 
   /* It's not a regular file, or it's a growing regular file; read it,
@@ -197,16 +176,16 @@ slurp (struct file_data *current)
   if (current->buffered)
     {
       while (current->buffered == current->bufsize)
-        {
-          if (PTRDIFF_MAX / 2 - sizeof (word) < current->bufsize)
-            xalloc_die ();
-          current->bufsize *= 2;
-          current->buffer = xrealloc (current->buffer, current->bufsize);
-          file_block_read (current, current->bufsize - current->buffered);
-        }
+	{
+	  if (PTRDIFF_MAX / 2 - sizeof (word) < current->bufsize)
+	    xalloc_die ();
+	  current->bufsize *= 2;
+	  current->buffer = xrealloc (current->buffer, current->bufsize);
+	  file_block_read (current, current->bufsize - current->buffered);
+	}
 
       /* Allocate just enough room for appended newline plus word
-         sentinel, plus word-alignment.  */
+	 sentinel, plus word-alignment.  */
       cc = current->buffered + 2 * sizeof (word);
       current->bufsize = cc - cc % sizeof (word);
       current->buffer = xrealloc (current->buffer, current->bufsize);
@@ -219,7 +198,9 @@ slurp (struct file_data *current)
 static void
 find_and_hash_each_line (struct file_data *current)
 {
+  hash_value h;
   char const *p = current->prefix_end;
+  unsigned char c;
   lin i, *bucket;
   size_t length;
 
@@ -234,112 +215,157 @@ find_and_hash_each_line (struct file_dat
   lin eqs_alloc = equivs_alloc;
   char const *suffix_begin = current->suffix_begin;
   char const *bufend = FILE_BUFFER (current) + current->buffered;
-  bool ig_case = ignore_case;
-  enum DIFF_white_space ig_white_space = ignore_white_space;
   bool diff_length_compare_anyway =
-    ig_white_space != IGNORE_NO_WHITE_SPACE;
+    ignore_white_space != IGNORE_NO_WHITE_SPACE;
   bool same_length_diff_contents_compare_anyway =
-    diff_length_compare_anyway | ig_case;
+    diff_length_compare_anyway | ignore_case;
 
   while (p < suffix_begin)
     {
       char const *ip = p;
-      hash_value h = 0;
-      unsigned char c;
+
+      h = 0;
 
       /* Hash this line until we find a newline.  */
-      switch (ig_white_space)
-        {
-        case IGNORE_ALL_SPACE:
-          while ((c = *p++) != '\n')
-            if (! isspace (c))
-              h = HASH (h, ig_case ? tolower (c) : c);
-          break;
-
-        case IGNORE_SPACE_CHANGE:
-          while ((c = *p++) != '\n')
-            {
-              if (isspace (c))
-                {
-                  do
-                    if ((c = *p++) == '\n')
-                      goto hashing_done;
-                  while (isspace (c));
-
-                  h = HASH (h, ' ');
-                }
-
-              /* C is now the first non-space.  */
-              h = HASH (h, ig_case ? tolower (c) : c);
-            }
-          break;
-
-        case IGNORE_TAB_EXPANSION:
-        case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
-        case IGNORE_TRAILING_SPACE:
-          {
-            size_t column = 0;
-            while ((c = *p++) != '\n')
-              {
-                if (ig_white_space & IGNORE_TRAILING_SPACE
-                    && isspace (c))
-                  {
-                    char const *p1 = p;
-                    unsigned char c1;
-                    do
-                      if ((c1 = *p1++) == '\n')
-                        {
-                          p = p1;
-                          goto hashing_done;
-                        }
-                    while (isspace (c1));
-                  }
-
-                size_t repetitions = 1;
-
-                if (ig_white_space & IGNORE_TAB_EXPANSION)
-                  switch (c)
-                    {
-                    case '\b':
-                      column -= 0 < column;
-                      break;
-
-                    case '\t':
-                      c = ' ';
-                      repetitions = tabsize - column % tabsize;
-                      column = (column + repetitions < column
-                                ? 0
-                                : column + repetitions);
-                      break;
-
-                    case '\r':
-                      column = 0;
-                      break;
-
-                    default:
-                      column++;
-                      break;
-                    }
-
-                if (ig_case)
-                  c = tolower (c);
-
-                do
-                  h = HASH (h, c);
-                while (--repetitions != 0);
-              }
-          }
-          break;
-
-        default:
-          if (ig_case)
-            while ((c = *p++) != '\n')
-              h = HASH (h, tolower (c));
-          else
-            while ((c = *p++) != '\n')
-              h = HASH (h, c);
-          break;
-        }
+      if (ignore_case)
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, tolower (c));
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, tolower (c));
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      c = tolower (c);
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, tolower (c));
+	    break;
+	  }
+      else
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, c);
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, c);
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, c);
+	    break;
+	  }
 
    hashing_done:;
 
@@ -347,75 +373,75 @@ find_and_hash_each_line (struct file_dat
       length = p - ip - 1;
 
       if (p == bufend
-          && current->missing_newline
-          && ROBUST_OUTPUT_STYLE (output_style))
-        {
-          /* The last line is incomplete and we do not silently
-             complete lines.  If the line cannot compare equal to any
-             complete line, put it into buckets[-1] so that it can
-             compare equal only to the other file's incomplete line
-             (if one exists).  */
-          if (ig_white_space < IGNORE_TRAILING_SPACE)
-            bucket = &buckets[-1];
-        }
+	  && current->missing_newline
+	  && ROBUST_OUTPUT_STYLE (output_style))
+	{
+	  /* The last line is incomplete and we do not silently
+	     complete lines.  If the line cannot compare equal to any
+	     complete line, put it into buckets[-1] so that it can
+	     compare equal only to the other file's incomplete line
+	     (if one exists).  */
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    bucket = &buckets[-1];
+	}
 
       for (i = *bucket;  ;  i = eqs[i].next)
-        if (!i)
-          {
-            /* Create a new equivalence class in this bucket.  */
-            i = eqs_index++;
-            if (i == eqs_alloc)
-              {
-                if (PTRDIFF_MAX / (2 * sizeof *eqs) <= eqs_alloc)
-                  xalloc_die ();
-                eqs_alloc *= 2;
-                eqs = xrealloc (eqs, eqs_alloc * sizeof *eqs);
-              }
-            eqs[i].next = *bucket;
-            eqs[i].hash = h;
-            eqs[i].line = ip;
-            eqs[i].length = length;
-            *bucket = i;
-            break;
-          }
-        else if (eqs[i].hash == h)
-          {
-            char const *eqline = eqs[i].line;
+	if (!i)
+	  {
+	    /* Create a new equivalence class in this bucket.  */
+	    i = eqs_index++;
+	    if (i == eqs_alloc)
+	      {
+		if (PTRDIFF_MAX / (2 * sizeof *eqs) <= eqs_alloc)
+		  xalloc_die ();
+		eqs_alloc *= 2;
+		eqs = xrealloc (eqs, eqs_alloc * sizeof *eqs);
+	      }
+	    eqs[i].next = *bucket;
+	    eqs[i].hash = h;
+	    eqs[i].line = ip;
+	    eqs[i].length = length;
+	    *bucket = i;
+	    break;
+	  }
+	else if (eqs[i].hash == h)
+	  {
+	    char const *eqline = eqs[i].line;
 
-            /* Reuse existing class if lines_differ reports the lines
+	    /* Reuse existing class if lines_differ reports the lines
                equal.  */
-            if (eqs[i].length == length)
-              {
-                /* Reuse existing equivalence class if the lines are identical.
-                   This detects the common case of exact identity
-                   faster than lines_differ would.  */
-                if (memcmp (eqline, ip, length) == 0)
-                  break;
-                if (!same_length_diff_contents_compare_anyway)
-                  continue;
-              }
-            else if (!diff_length_compare_anyway)
-              continue;
-
-            if (! lines_differ (eqline, ip))
-              break;
-          }
+	    if (eqs[i].length == length)
+	      {
+		/* Reuse existing equivalence class if the lines are identical.
+		   This detects the common case of exact identity
+		   faster than lines_differ would.  */
+		if (memcmp (eqline, ip, length) == 0)
+		  break;
+		if (!same_length_diff_contents_compare_anyway)
+		  continue;
+	      }
+	    else if (!diff_length_compare_anyway)
+	      continue;
+
+	    if (! lines_differ (eqline, ip))
+	      break;
+	  }
 
       /* Maybe increase the size of the line table.  */
       if (line == alloc_lines)
-        {
-          /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
-          if (PTRDIFF_MAX / 3 <= alloc_lines
-              || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
-              || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
-            xalloc_die ();
-          alloc_lines = 2 * alloc_lines - linbuf_base;
-          cureqs = xrealloc (cureqs, alloc_lines * sizeof *cureqs);
-          linbuf += linbuf_base;
-          linbuf = xrealloc (linbuf,
-                             (alloc_lines - linbuf_base) * sizeof *linbuf);
-          linbuf -= linbuf_base;
-        }
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  cureqs = xrealloc (cureqs, alloc_lines * sizeof *cureqs);
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
       linbuf[line] = ip;
       cureqs[line] = i;
       ++line;
@@ -426,39 +452,39 @@ find_and_hash_each_line (struct file_dat
   for (i = 0;  ;  i++)
     {
       /* Record the line start for lines in the suffix that we care about.
-         Record one more line start than lines,
-         so that we can compute the length of any buffered line.  */
+	 Record one more line start than lines,
+	 so that we can compute the length of any buffered line.  */
       if (line == alloc_lines)
-        {
-          /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
-          if (PTRDIFF_MAX / 3 <= alloc_lines
-              || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
-              || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
-            xalloc_die ();
-          alloc_lines = 2 * alloc_lines - linbuf_base;
-          linbuf += linbuf_base;
-          linbuf = xrealloc (linbuf,
-                             (alloc_lines - linbuf_base) * sizeof *linbuf);
-          linbuf -= linbuf_base;
-        }
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
       linbuf[line] = p;
 
       if (p == bufend)
-        {
-          /* If the last line is incomplete and we do not silently
-             complete lines, don't count its appended newline.  */
-          if (current->missing_newline && ROBUST_OUTPUT_STYLE (output_style))
-            linbuf[line]--;
-          break;
-        }
+	{
+	  /* If the last line is incomplete and we do not silently
+	     complete lines, don't count its appended newline.  */
+	  if (current->missing_newline && ROBUST_OUTPUT_STYLE (output_style))
+	    linbuf[line]--;
+	  break;
+	}
 
       if (context <= i && no_diff_means_no_output)
-        break;
+	break;
 
       line++;
 
       while (*p++ != '\n')
-        continue;
+	continue;
     }
 
   /* Done with cache in local variables.  */
@@ -481,33 +507,34 @@ prepare_text (struct file_data *current)
 {
   size_t buffered = current->buffered;
   char *p = FILE_BUFFER (current);
-  if (!p)
-    return;
-
-  if (strip_trailing_cr)
-    {
-      char *srclim = p + buffered;
-      *srclim = '\r';
-      char *dst = rawmemchr (p, '\r');
-
-      for (char const *src = dst; src != srclim; src++)
-        {
-          src += *src == '\r' && src[1] == '\n';
-          *dst++ = *src;
-        }
-
-      buffered -= srclim - dst;
-    }
+  char *dst;
 
-  if (buffered != 0 && p[buffered - 1] != '\n')
+  if (buffered == 0 || p[buffered - 1] == '\n')
+    current->missing_newline = false;
+  else
     {
       p[buffered++] = '\n';
       current->missing_newline = true;
     }
 
+  if (!p)
+    return;
+
   /* Don't use uninitialized storage when planting or using sentinels.  */
   memset (p + buffered, 0, sizeof (word));
 
+  if (strip_trailing_cr && (dst = memchr (p, '\r', buffered)))
+    {
+      char const *src = dst;
+      char const *srclim = p + buffered;
+
+      do
+	dst += ! ((*dst = *src++) == '\r' && *src == '\n');
+      while (src < srclim);
+
+      buffered -= src - dst;
+    }
+
   current->buffered = buffered;
 }
 
@@ -536,7 +563,6 @@ find_identical_ends (struct file_data fi
   lin i, lines;
   size_t n0, n1;
   lin alloc_lines0, alloc_lines1;
-  bool prefix_needed;
   lin buffered_prefix, prefix_count, prefix_mask;
   lin middle_guess, suffix_guess;
 
@@ -570,31 +596,31 @@ find_identical_ends (struct file_data fi
   else
     {
       /* Insert end sentinels, in this case characters that are guaranteed
-         to make the equality test false, and thus terminate the loop.  */
+	 to make the equality test false, and thus terminate the loop.  */
 
       if (n0 < n1)
-        p0[n0] = ~p1[n0];
+	p0[n0] = ~p1[n0];
       else
-        p1[n1] = ~p0[n1];
+	p1[n1] = ~p0[n1];
 
       /* Loop until first mismatch, or to the sentinel characters.  */
 
       /* Compare a word at a time for speed.  */
       while (*w0 == *w1)
-        w0++, w1++;
+	w0++, w1++;
 
       /* Do the last few bytes of comparison a byte at a time.  */
       p0 = (char *) w0;
       p1 = (char *) w1;
       while (*p0 == *p1)
-        p0++, p1++;
+	p0++, p1++;
 
       /* Don't mistakenly count missing newline as part of prefix.  */
       if (ROBUST_OUTPUT_STYLE (output_style)
-          && ((buffer0 + n0 - filevec[0].missing_newline < p0)
-              !=
-              (buffer1 + n1 - filevec[1].missing_newline < p1)))
-        p0--, p1--;
+	  && ((buffer0 + n0 - filevec[0].missing_newline < p0)
+	      !=
+	      (buffer1 + n1 - filevec[1].missing_newline < p1)))
+	p0--, p1--;
     }
 
   /* Now P0 and P1 point at the first nonmatching characters.  */
@@ -621,30 +647,30 @@ find_identical_ends (struct file_data fi
       end0 = p0;	/* Addr of last char in file 0.  */
 
       /* Get value of P0 at which we should stop scanning backward:
-         this is when either P0 or P1 points just past the last char
-         of the identical prefix.  */
+	 this is when either P0 or P1 points just past the last char
+	 of the identical prefix.  */
       beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);
 
       /* Scan back until chars don't match or we reach that point.  */
       while (p0 != beg0)
-        if (*--p0 != *--p1)
-          {
-            /* Point at the first char of the matching suffix.  */
-            ++p0, ++p1;
-            beg0 = p0;
-            break;
-          }
+	if (*--p0 != *--p1)
+	  {
+	    /* Point at the first char of the matching suffix.  */
+	    ++p0, ++p1;
+	    beg0 = p0;
+	    break;
+	  }
 
       /* Are we at a line-beginning in both files?  If not, add the rest of
-         this line to the main body.  Discard up to HORIZON_LINES lines from
-         the identical suffix.  Also, discard one extra line,
-         because shift_boundaries may need it.  */
+	 this line to the main body.  Discard up to HORIZON_LINES lines from
+	 the identical suffix.  Also, discard one extra line,
+	 because shift_boundaries may need it.  */
       i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n')
-                            &&
-                            (buffer1 == p1 || p1[-1] == '\n'));
+			    &&
+			    (buffer1 == p1 || p1[-1] == '\n'));
       while (i-- && p0 != end0)
-        while (*p0++ != '\n')
-          continue;
+	while (*p0++ != '\n')
+	  continue;
 
       p1 += p0 - beg0;
     }
@@ -673,9 +699,9 @@ find_identical_ends (struct file_data fi
       middle_guess = guess_lines (0, 0, p0 - filevec[0].prefix_end);
       suffix_guess = guess_lines (0, 0, buffer0 + n0 - p0);
       for (prefix_count = 1;  prefix_count <= context;  prefix_count *= 2)
-        continue;
+	continue;
       alloc_lines0 = (prefix_count + middle_guess
-                      + MIN (context, suffix_guess));
+		      + MIN (context, suffix_guess));
     }
   else
     {
@@ -686,29 +712,28 @@ find_identical_ends (struct file_data fi
   prefix_mask = prefix_count - 1;
   lines = 0;
   linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
-  prefix_needed = ! (no_diff_means_no_output
-                     && filevec[0].prefix_end == p0
-                     && filevec[1].prefix_end == p1);
   p0 = buffer0;
 
   /* If the prefix is needed, find the prefix lines.  */
-  if (prefix_needed)
+  if (! (no_diff_means_no_output
+	 && filevec[0].prefix_end == p0
+	 && filevec[1].prefix_end == p1))
     {
       end0 = filevec[0].prefix_end;
       while (p0 != end0)
-        {
-          lin l = lines++ & prefix_mask;
-          if (l == alloc_lines0)
-            {
-              if (PTRDIFF_MAX / (2 * sizeof *linbuf0) <= alloc_lines0)
-                xalloc_die ();
-              alloc_lines0 *= 2;
-              linbuf0 = xrealloc (linbuf0, alloc_lines0 * sizeof *linbuf0);
-            }
-          linbuf0[l] = p0;
-          while (*p0++ != '\n')
-            continue;
-        }
+	{
+	  lin l = lines++ & prefix_mask;
+	  if (l == alloc_lines0)
+	    {
+	      if (PTRDIFF_MAX / (2 * sizeof *linbuf0) <= alloc_lines0)
+		xalloc_die ();
+	      alloc_lines0 *= 2;
+	      linbuf0 = xrealloc (linbuf0, alloc_lines0 * sizeof *linbuf0);
+	    }
+	  linbuf0[l] = p0;
+	  while (*p0++ != '\n')
+	    continue;
+	}
     }
   buffered_prefix = prefix_count && context < lines ? context : lines;
 
@@ -726,9 +751,9 @@ find_identical_ends (struct file_data fi
     {
       /* Rotate prefix lines to proper location.  */
       for (i = 0;  i < buffered_prefix;  i++)
-        linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
+	linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
       for (i = 0;  i < buffered_prefix;  i++)
-        linbuf0[i] = linbuf1[i];
+	linbuf0[i] = linbuf1[i];
     }
 
   /* Initialize line buffer 1 from line buffer 0.  */
@@ -783,8 +808,7 @@ read_files (struct file_data filevec[],
     }
   if (appears_binary)
     {
-      set_binary_mode (filevec[0].desc, O_BINARY);
-      set_binary_mode (filevec[1].desc, O_BINARY);
+      /* FIXME: If O_BINARY, this should set both files to binary mode.  */
       return true;
     }
 
diff -pru diffutils-3.0/normal.c diffutils-3.0-patch/normal.c
--- diffutils-3.0/normal.c	2020-05-30 16:24:16.389925000 -0700
+++ diffutils-3.0-patch/normal.c	2020-05-30 15:52:03.070063000 -0700
@@ -1,7 +1,7 @@
 /* Normal-format output routines for GNU DIFF.
 
-   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2013, 2015-2020
-   Free Software Foundation, Inc.
+   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2010 Free
+   Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -49,39 +49,21 @@ print_normal_hunk (struct change *hunk)
   begin_output ();
 
   /* Print out the line number header for this hunk */
-  set_color_context (LINE_NUMBER_CONTEXT);
   print_number_range (',', &files[0], first0, last0);
   fputc (change_letter[changes], outfile);
   print_number_range (',', &files[1], first1, last1);
-  set_color_context (RESET_CONTEXT);
   fputc ('\n', outfile);
 
   /* Print the lines that the first file has.  */
   if (changes & OLD)
-    {
-      for (i = first0; i <= last0; i++)
-        {
-          set_color_context (DELETE_CONTEXT);
-          print_1_line_nl ("<", &files[0].linbuf[i], true);
-          set_color_context (RESET_CONTEXT);
-          if (files[0].linbuf[i + 1][-1] == '\n')
-            putc ('\n', outfile);
-        }
-    }
+    for (i = first0; i <= last0; i++)
+      print_1_line ("<", &files[0].linbuf[i]);
 
   if (changes == CHANGED)
     fputs ("---\n", outfile);
 
   /* Print the lines that the second file has.  */
   if (changes & NEW)
-    {
-      for (i = first1; i <= last1; i++)
-        {
-          set_color_context (ADD_CONTEXT);
-          print_1_line_nl (">", &files[1].linbuf[i], true);
-          set_color_context (RESET_CONTEXT);
-          if (files[1].linbuf[i + 1][-1] == '\n')
-            putc ('\n', outfile);
-        }
-    }
+    for (i = first1; i <= last1; i++)
+      print_1_line (">", &files[1].linbuf[i]);
 }
diff -pru diffutils-3.0/sdiff.c diffutils-3.0-patch/sdiff.c
--- diffutils-3.0/sdiff.c	2020-05-30 16:24:16.391923000 -0700
+++ diffutils-3.0-patch/sdiff.c	2020-05-30 15:52:03.072063000 -0700
@@ -1,7 +1,7 @@
-/* GNU sdiff - side-by-side merge of file differences
+/* sdiff - side-by-side merge of file differences
 
-   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
-   2015-2020 Free Software Foundation, Inc.
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -26,16 +26,14 @@
 
 #include <c-stack.h>
 #include <dirname.h>
-#include "die.h"
 #include <error.h>
 #include <exitfail.h>
 #include <file-type.h>
 #include <getopt.h>
 #include <progname.h>
-#include <system-quote.h>
+#include <sh-quote.h>
 #include <version-etc.h>
 #include <xalloc.h>
-#include <xstdopen.h>
 
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "sdiff"
@@ -52,7 +50,7 @@ static char const **diffargv;
 static char * volatile tmpname;
 static FILE *tmp;
 
-#if HAVE_WORKING_FORK
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
 static pid_t volatile diffpid;
 #endif
 
@@ -68,6 +66,7 @@ static void perror_fatal (char const *)
 static void trapsigs (void);
 static void untrapsig (int);
 
+#define NUM_SIGS (sizeof sigs / sizeof *sigs)
 static int const sigs[] = {
 #ifdef SIGHUP
        SIGHUP,
@@ -86,17 +85,14 @@ static int const sigs[] = {
 #endif
 #ifdef SIGPIPE
        SIGPIPE,
+# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
 #endif
        SIGINT
+#define handler_index_of_SIGINT (NUM_SIGS - 1)
 };
-enum
-  {
-    NUM_SIGS = sizeof sigs / sizeof *sigs,
-    handler_index_of_SIGINT = NUM_SIGS - 1
-  };
 
 #if HAVE_SIGACTION
-  /* Prefer 'sigaction' if available, since 'signal' can lose signals.  */
+  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
   static struct sigaction initial_action[NUM_SIGS];
 # define initial_handler(i) (initial_action[i].sa_handler)
   static void signal_handler (int, void (*) (int));
@@ -106,6 +102,29 @@ enum
 # define signal_handler(sig, handler) signal (sig, handler)
 #endif
 
+#if ! HAVE_SIGPROCMASK
+# define sigset_t int
+# define sigemptyset(s) (*(s) = 0)
+# ifndef sigmask
+#  define sigmask(sig) (1 << ((sig) - 1))
+# endif
+# define sigaddset(s, sig) (*(s) |= sigmask (sig))
+# ifndef SIG_BLOCK
+#  define SIG_BLOCK 0
+# endif
+# ifndef SIG_SETMASK
+#  define SIG_SETMASK (! SIG_BLOCK)
+# endif
+# if ! HAVE_SIGBLOCK
+#  define sigblock(mask) (mask)
+#  define sigsetmask(mask) (mask)
+# endif
+# define sigprocmask(how, n, o) \
+    ((how) == SIG_BLOCK \
+     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
+     : sigsetmask (*(n)))
+#endif
+
 static bool diraccess (char const *);
 static int temporary_file (void);
 
@@ -137,7 +156,6 @@ static struct option const longopts[] =
   {"ignore-matching-lines", 1, 0, 'I'},
   {"ignore-space-change", 0, 0, 'b'},
   {"ignore-tab-expansion", 0, 0, 'E'},
-  {"ignore-trailing-space", 0, 0, 'Z'},
   {"left-column", 0, 0, 'l'},
   {"minimal", 0, 0, 'd'},
   {"output", 1, 0, 'o'},
@@ -157,8 +175,9 @@ try_help (char const *reason_msgid, char
 {
   if (reason_msgid)
     error (0, 0, _(reason_msgid), operand);
-  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
-         program_name);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
 }
 
 static void
@@ -171,31 +190,30 @@ check_stdout (void)
 }
 
 static char const * const option_help_msgid[] = {
-  N_("-o, --output=FILE            operate interactively, sending output to FILE"),
+  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
   "",
-  N_("-i, --ignore-case            consider upper- and lower-case to be the same"),
-  N_("-E, --ignore-tab-expansion   ignore changes due to tab expansion"),
-  N_("-Z, --ignore-trailing-space  ignore white space at line end"),
-  N_("-b, --ignore-space-change    ignore changes in the amount of white space"),
-  N_("-W, --ignore-all-space       ignore all white space"),
-  N_("-B, --ignore-blank-lines     ignore changes whose lines are all blank"),
-  N_("-I, --ignore-matching-lines=RE  ignore changes all whose lines match RE"),
-  N_("    --strip-trailing-cr      strip trailing carriage return on input"),
-  N_("-a, --text                   treat all files as text"),
+  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-W  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-a  --text  Treat all files as text."),
   "",
-  N_("-w, --width=NUM              output at most NUM (default 130) print columns"),
-  N_("-l, --left-column            output only the left column of common lines"),
-  N_("-s, --suppress-common-lines  do not output common lines"),
+  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
+  N_("-l  --left-column  Output only the left column of common lines."),
+  N_("-s  --suppress-common-lines  Do not output common lines."),
   "",
-  N_("-t, --expand-tabs            expand tabs to spaces in output"),
-  N_("    --tabsize=NUM            tab stops at every NUM (default 8) print columns"),
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
   "",
-  N_("-d, --minimal                try hard to find a smaller set of changes"),
-  N_("-H, --speed-large-files      assume large files, many scattered small changes"),
-  N_("    --diff-program=PROGRAM   use PROGRAM to compare files"),
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
   "",
-  N_("    --help                   display this help and exit"),
-  N_("-v, --version                output version information and exit"),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
   0
 };
 
@@ -205,20 +223,15 @@ usage (void)
   char const * const *p;
 
   printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
-  printf ("%s\n\n",
-          _("Side-by-side merge of differences between FILE1 and FILE2."));
-
-  fputs (_("\
-Mandatory arguments to long options are mandatory for short options too.\n\
-"), stdout);
+  printf ("%s\n\n", _("Side-by-side merge of file differences."));
   for (p = option_help_msgid;  *p;  p++)
     if (**p)
       printf ("  %s\n", _(*p));
     else
       putchar ('\n');
   printf ("\n%s\n%s\n",
-          _("If a FILE is '-', read standard input."),
-          _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
   emit_bug_reporting_address ();
 }
 
@@ -227,7 +240,7 @@ Mandatory arguments to long options are
 static void
 cleanup (int signo __attribute__((unused)))
 {
-#if HAVE_WORKING_FORK
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
   if (0 < diffpid)
     kill (diffpid, SIGPIPE);
 #endif
@@ -263,23 +276,23 @@ perror_fatal (char const *msg)
 
 static void
 check_child_status (int werrno, int wstatus, int max_ok_status,
-                    char const *subsidiary_program)
+		    char const *subsidiary_program)
 {
   int status = (! werrno && WIFEXITED (wstatus)
-                ? WEXITSTATUS (wstatus)
-                : INT_MAX);
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
 
   if (max_ok_status < status)
     {
       error (0, werrno,
-             _(status == 126
-               ? "subsidiary program '%s' could not be invoked"
-               : status == 127
-               ? "subsidiary program '%s' not found"
-               : status == INT_MAX
-               ? "subsidiary program '%s' failed"
-               : "subsidiary program '%s' failed (exit status %d)"),
-             subsidiary_program, status);
+	     _(status == 126
+	       ? "subsidiary program '%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program '%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
+	     subsidiary_program, status);
       exiterr ();
     }
 }
@@ -380,19 +393,19 @@ lf_copy (struct line_filter *lf, lin lin
 
   while (lines)
     {
-      lf->bufpos = rawmemchr (lf->bufpos, '\n');
-      if (lf->bufpos == lf->buflim)
-        {
-          ck_fwrite (start, lf->buflim - start, outfile);
-          if (! lf_refill (lf))
-            return;
-          start = lf->bufpos;
-        }
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
       else
-        {
-          --lines;
-          ++lf->bufpos;
-        }
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
     }
 
   ck_fwrite (start, lf->bufpos - start, outfile);
@@ -404,17 +417,17 @@ lf_skip (struct line_filter *lf, lin lin
 {
   while (lines)
     {
-      lf->bufpos = rawmemchr (lf->bufpos, '\n');
-      if (lf->bufpos == lf->buflim)
-        {
-          if (! lf_refill (lf))
-            break;
-        }
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
       else
-        {
-          --lines;
-          ++lf->bufpos;
-        }
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
     }
 }
 
@@ -425,19 +438,19 @@ lf_snarf (struct line_filter *lf, char *
   for (;;)
     {
       char *start = lf->bufpos;
-      char *next = rawmemchr (start, '\n');
+      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
       size_t s = next - start;
       if (bufsize <= s)
-        return 0;
+	return 0;
       memcpy (buffer, start, s);
       if (next < lf->buflim)
-        {
-          buffer[s] = 0;
-          lf->bufpos = next + 1;
-          return 1;
-        }
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
       if (! lf_refill (lf))
-        return s ? 0 : EOF;
+	return s ? 0 : EOF;
       buffer += s;
       bufsize -= s;
     }
@@ -456,7 +469,6 @@ main (int argc, char *argv[])
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
   c_stack_action (cleanup);
-  xstdopen ();
 
   prog = getenv ("EDITOR");
   if (prog)
@@ -465,115 +477,111 @@ main (int argc, char *argv[])
   diffarg (DEFAULT_DIFF_PROGRAM);
 
   /* parse command line args */
-  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:WZ", longopts, 0))
-         != -1)
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+	 != -1)
     {
       switch (opt)
-        {
-        case 'a':
-          diffarg ("-a");
-          break;
-
-        case 'b':
-          diffarg ("-b");
-          break;
-
-        case 'B':
-          diffarg ("-B");
-          break;
-
-        case 'd':
-          diffarg ("-d");
-          break;
-
-        case 'E':
-          diffarg ("-E");
-          break;
-
-        case 'H':
-          diffarg ("-H");
-          break;
-
-        case 'i':
-          diffarg ("-i");
-          break;
-
-        case 'I':
-          diffarg ("-I");
-          diffarg (optarg);
-          break;
-
-        case 'l':
-          diffarg ("--left-column");
-          break;
-
-        case 'o':
-          output = optarg;
-          break;
-
-        case 's':
-          suppress_common_lines = true;
-          break;
-
-        case 't':
-          diffarg ("-t");
-          break;
-
-        case 'v':
-          version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
-                       AUTHORS, (char *) NULL);
-          check_stdout ();
-          return EXIT_SUCCESS;
-
-        case 'w':
-          diffarg ("-W");
-          diffarg (optarg);
-          break;
-
-        case 'W':
-          diffarg ("-w");
-          break;
-
-        case 'Z':
-          diffarg ("-Z");
-          break;
-
-        case DIFF_PROGRAM_OPTION:
-          diffargv[0] = optarg;
-          break;
-
-        case HELP_OPTION:
-          usage ();
-          check_stdout ();
-          return EXIT_SUCCESS;
-
-        case STRIP_TRAILING_CR_OPTION:
-          diffarg ("--strip-trailing-cr");
-          break;
-
-        case TABSIZE_OPTION:
-          diffarg ("--tabsize");
-          diffarg (optarg);
-          break;
-
-        default:
-          try_help (0, 0);
-        }
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
     }
 
   if (argc - optind != 2)
     {
       if (argc - optind < 2)
-        try_help ("missing operand after '%s'", argv[argc - 1]);
+	try_help ("missing operand after '%s'", argv[argc - 1]);
       else
-        try_help ("extra operand '%s'", argv[optind + 2]);
+	try_help ("extra operand '%s'", argv[optind + 2]);
     }
 
   if (! output)
     {
       /* easy case: diff does everything for us */
       if (suppress_common_lines)
-        diffarg ("--suppress-common-lines");
+	diffarg ("--suppress-common-lines");
       diffarg ("-y");
       diffarg ("--");
       diffarg (argv[optind]);
@@ -594,7 +602,7 @@ main (int argc, char *argv[])
       bool rightdir = diraccess (argv[optind + 1]);
 
       if (leftdir & rightdir)
-        fatal ("both files to be compared are directories");
+	fatal ("both files to be compared are directories");
 
       lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
       left = ck_fopen (lname, "r");
@@ -610,49 +618,89 @@ main (int argc, char *argv[])
 
       trapsigs ();
 
-#if ! HAVE_WORKING_FORK
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
       {
-        char *command = system_quote_argv (SCI_SYSTEM, (char **) diffargv);
-        errno = 0;
-        diffout = popen (command, "r");
-        if (! diffout)
-          perror_fatal (command);
-        free (command);
+	size_t cmdsize = 1;
+	char *p, *command;
+	int i;
+
+	for (i = 0;  diffargv[i];  i++)
+	  cmdsize += shell_quote_length (diffargv[i]) + 1;
+	command = p = xmalloc (cmdsize);
+	for (i = 0;  diffargv[i];  i++)
+	  {
+	    p = shell_quote_copy (p, diffargv[i]);
+	    *p++ = ' ';
+	  }
+	p[-1] = 0;
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
       }
 #else
       {
-        int diff_fds[2];
-
-        if (pipe (diff_fds) != 0)
-          perror_fatal ("pipe");
-
-        diffpid = fork ();
-        if (diffpid < 0)
-          perror_fatal ("fork");
-        if (! diffpid)
-          {
-            /* Alter the child's SIGINT and SIGPIPE handlers;
-               this may munge the parent.
-               The child ignores SIGINT in case the user interrupts the editor.
-               The child does not ignore SIGPIPE, even if the parent does.  */
-            if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
-              signal_handler (SIGINT, SIG_IGN);
-            signal_handler (SIGPIPE, SIG_DFL);
-            close (diff_fds[0]);
-            if (diff_fds[1] != STDOUT_FILENO)
-              {
-                dup2 (diff_fds[1], STDOUT_FILENO);
-                close (diff_fds[1]);
-              }
-
-            execvp (diffargv[0], (char **) diffargv);
-            _exit (errno == ENOENT ? 127 : 126);
-          }
-
-        close (diff_fds[1]);
-        diffout = fdopen (diff_fds[0], "r");
-        if (! diffout)
-          perror_fatal ("fdopen");
+	int diff_fds[2];
+# if HAVE_WORKING_VFORK
+	sigset_t procmask;
+	sigset_t blocked;
+# endif
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+# if HAVE_WORKING_VFORK
+	/* Block SIGINT and SIGPIPE.  */
+	sigemptyset (&blocked);
+	sigaddset (&blocked, SIGINT);
+	sigaddset (&blocked, SIGPIPE);
+	sigprocmask (SIG_BLOCK, &blocked, &procmask);
+# endif
+	diffpid = vfork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+# if HAVE_WORKING_VFORK
+	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
+	    sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+# if HAVE_WORKING_VFORK
+	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
+	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	  signal_handler (SIGINT, catchsig);
+	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
+	  signal_handler (SIGPIPE, catchsig);
+	else
+	  signal_handler (SIGPIPE, SIG_IGN);
+
+	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
+	sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
       }
 #endif
 
@@ -667,36 +715,36 @@ main (int argc, char *argv[])
       ck_fclose (out);
 
       {
-        int wstatus;
-        int werrno = 0;
+	int wstatus;
+	int werrno = 0;
 
-#if ! HAVE_WORKING_FORK
-        wstatus = pclose (diffout);
-        if (wstatus == -1)
-          werrno = errno;
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
 #else
-        ck_fclose (diffout);
-        while (waitpid (diffpid, &wstatus, 0) < 0)
-          if (errno == EINTR)
-            checksigs ();
-          else
-            perror_fatal ("waitpid");
-        diffpid = 0;
-#endif
-
-        if (tmpname)
-          {
-            unlink (tmpname);
-            tmpname = 0;
-          }
-
-        if (! interact_ok)
-          exiterr ();
-
-        check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
-        untrapsig (0);
-        checksigs ();
-        exit (WEXITSTATUS (wstatus));
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
       }
     }
   return EXIT_SUCCESS;			/* Fool '-Wall'.  */
@@ -710,11 +758,11 @@ diffarg (char const *a)
   if (diffargs == diffarglim)
     {
       if (! diffarglim)
-        diffarglim = 16;
+	diffarglim = 16;
       else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
-        xalloc_die ();
+	xalloc_die ();
       else
-        diffarglim *= 2;
+	diffarglim *= 2;
       diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
     }
   diffargv[diffargs++] = a;
@@ -767,7 +815,7 @@ trapsigs (void)
       initial_action[i] = signal (sigs[i], SIG_IGN);
 #endif
       if (initial_handler (i) != SIG_IGN)
-        signal_handler (sigs[i], catchsig);
+	signal_handler (sigs[i], catchsig);
     }
 
 #ifdef SIGCHLD
@@ -787,13 +835,13 @@ untrapsig (int s)
   if (sigs_trapped)
     for (i = 0;  i < NUM_SIGS;  i++)
       if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
-        {
+	{
 #if HAVE_SIGACTION
-          sigaction (sigs[i], &initial_action[i], 0);
+	  sigaction (sigs[i], &initial_action[i], 0);
 #else
-          signal (sigs[i], initial_action[i]);
+	  signal (sigs[i], initial_action[i]);
 #endif
-        }
+	}
 }
 
 /* Exit if a signal has been received.  */
@@ -807,7 +855,7 @@ checksigs (void)
 
       /* Yield an exit status indicating that a signal was received.  */
       untrapsig (s);
-      raise (s);
+      kill (getpid (), s);
 
       /* That didn't work, so exit with error status.  */
       exit (EXIT_TROUBLE);
@@ -839,7 +887,7 @@ skip_white (void)
     {
       c = getchar ();
       if (! isspace (c) || c == '\n')
-        break;
+	break;
       checksigs ();
     }
   if (ferror (stdin))
@@ -871,215 +919,221 @@ edit (struct line_filter *left, char con
       bool gotcmd = false;
 
       while (! gotcmd)
-        {
-          if (putchar ('%') != '%')
-            perror_fatal (_("write failed"));
-          ck_fflush (stdout);
-
-          cmd0 = skip_white ();
-          switch (cmd0)
-            {
-            case '1': case '2': case 'l': case 'r':
-            case 's': case 'v': case 'q':
-              if (skip_white () != '\n')
-                {
-                  give_help ();
-                  flush_line ();
-                  continue;
-                }
-              gotcmd = true;
-              break;
-
-            case 'e':
-              cmd1 = skip_white ();
-              switch (cmd1)
-                {
-                case '1': case '2': case 'b': case 'd': case 'l': case 'r':
-                  if (skip_white () != '\n')
-                    {
-                      give_help ();
-                      flush_line ();
-                      continue;
-                    }
-                  gotcmd = true;
-                  break;
-                case '\n':
-                  gotcmd = true;
-                  break;
-                default:
-                  give_help ();
-                  flush_line ();
-                  continue;
-                }
-              break;
-
-            case EOF:
-              if (feof (stdin))
-                {
-                  gotcmd = true;
-                  cmd0 = 'q';
-                  break;
-                }
-              FALLTHROUGH;
-            default:
-              flush_line ();
-              FALLTHROUGH;
-            case '\n':
-              give_help ();
-              continue;
-            }
-        }
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      /* Fall through.  */
+	    default:
+	      flush_line ();
+	      /* Fall through.  */
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
 
       switch (cmd0)
-        {
-        case '1': case 'l':
-          lf_copy (left, llen, outfile);
-          lf_skip (right, rlen);
-          return true;
-        case '2': case 'r':
-          lf_copy (right, rlen, outfile);
-          lf_skip (left, llen);
-          return true;
-        case 's':
-          suppress_common_lines = true;
-          break;
-        case 'v':
-          suppress_common_lines = false;
-          break;
-        case 'q':
-          return false;
-        case 'e':
-          {
-            int fd;
-
-            if (tmpname)
-              tmp = fopen (tmpname, "w");
-            else
-              {
-                if ((fd = temporary_file ()) < 0)
-                  perror_fatal ("mkstemp");
-                tmp = fdopen (fd, "w");
-              }
-
-            if (! tmp)
-              perror_fatal (tmpname);
-
-            switch (cmd1)
-              {
-              case 'd':
-                if (llen)
-                  {
-                    printint l1 = lline;
-                    printint l2 = lline + llen - 1;
-                    if (llen == 1)
-                      fprintf (tmp, "--- %s %"pI"d\n", lname, l1);
-                    else
-                      fprintf (tmp, "--- %s %"pI"d,%"pI"d\n", lname, l1, l2);
-                  }
-                FALLTHROUGH;
-              case '1': case 'b': case 'l':
-                lf_copy (left, llen, tmp);
-                break;
-
-              default:
-                lf_skip (left, llen);
-                break;
-              }
-
-            switch (cmd1)
-              {
-              case 'd':
-                if (rlen)
-                  {
-                    printint l1 = rline;
-                    printint l2 = rline + rlen - 1;
-                    if (rlen == 1)
-                      fprintf (tmp, "+++ %s %"pI"d\n", rname, l1);
-                    else
-                      fprintf (tmp, "+++ %s %"pI"d,%"pI"d\n", rname, l1, l2);
-                  }
-                FALLTHROUGH;
-              case '2': case 'b': case 'r':
-                lf_copy (right, rlen, tmp);
-                break;
-
-              default:
-                lf_skip (right, rlen);
-                break;
-              }
-
-            ck_fclose (tmp);
-
-            {
-              int wstatus;
-              int werrno = 0;
-              char const *argv[3];
-
-              ignore_SIGINT = true;
-              checksigs ();
-              argv[0] = editor_program;
-              argv[1] = tmpname;
-              argv[2] = 0;
-
-              {
-#if ! HAVE_WORKING_FORK
-                char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
-                wstatus = system (command);
-                if (wstatus == -1)
-                  werrno = errno;
-                free (command);
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+		    else
+		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
+			       (long int) lline,
+			       (long int) (lline + llen - 1));
+		  }
+		/* Fall through.  */
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+		    else
+		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
+			       (long int) rline,
+			       (long int) (rline + rlen - 1));
+		  }
+		/* Fall through.  */
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      ignore_SIGINT = true;
+	      checksigs ();
+
+	      {
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+		char *command =
+		  xmalloc (shell_quote_length (editor_program)
+			   + 1 + strlen (tmpname) + 1);
+		sprintf (shell_quote_copy (command, editor_program),
+			 " %s", tmpname);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
 #else
-                pid_t pid;
+		pid_t pid;
+
+		pid = vfork ();
+		if (pid == 0)
+		  {
+		    char const *argv[3];
+		    int i = 0;
+
+		    argv[i++] = editor_program;
+		    argv[i++] = tmpname;
+		    argv[i] = 0;
+
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
 
-                pid = fork ();
-                if (pid == 0)
-                  {
-                    execvp (editor_program, (char **) argv);
-                    _exit (errno == ENOENT ? 127 : 126);
-                  }
-
-                if (pid < 0)
-                  perror_fatal ("fork");
-
-                while (waitpid (pid, &wstatus, 0) < 0)
-                  if (errno == EINTR)
-                    checksigs ();
-                  else
-                    perror_fatal ("waitpid");
-#endif
-              }
-
-              ignore_SIGINT = false;
-              check_child_status (werrno, wstatus, EXIT_SUCCESS,
-                                  editor_program);
-            }
-
-            {
-              char buf[SDIFF_BUFSIZE];
-              size_t size;
-              tmp = ck_fopen (tmpname, "r");
-              while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
-                {
-                  checksigs ();
-                  ck_fwrite (buf, size, outfile);
-                }
-              ck_fclose (tmp);
-            }
-            return true;
-          }
-        default:
-          give_help ();
-          break;
-        }
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
     }
 }
 
 /* Alternately reveal bursts of diff output and handle user commands.  */
 static bool
 interact (struct line_filter *diff,
-          struct line_filter *left, char const *lname,
-          struct line_filter *right, char const *rname,
-          FILE *outfile)
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
 {
   lin lline = 1, rline = 1;
 
@@ -1089,56 +1143,54 @@ interact (struct line_filter *diff,
       int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
 
       if (snarfed <= 0)
-        return snarfed != 0;
+	return snarfed != 0;
 
       checksigs ();
 
       if (diff_help[0] == ' ')
-        puts (diff_help + 1);
+	puts (diff_help + 1);
       else
-        {
-          char *numend;
-          intmax_t val;
-          lin llen, rlen, lenmax;
-          errno = 0;
-          val = strtoimax (diff_help + 1, &numend, 10);
-          if (! (0 <= val && val <= LIN_MAX) || errno || *numend != ',')
-            fatal (diff_help);
-          llen = val;
-          val = strtoimax (numend + 1, &numend, 10);
-          if (! (0 <= val && val <= LIN_MAX) || errno || *numend)
-            fatal (diff_help);
-          rlen = val;
-
-          lenmax = MAX (llen, rlen);
-
-          switch (diff_help[0])
-            {
-            case 'i':
-              if (suppress_common_lines)
-                lf_skip (diff, lenmax);
-              else
-                lf_copy (diff, lenmax, stdout);
-
-              lf_copy (left, llen, outfile);
-              lf_skip (right, rlen);
-              break;
-
-            case 'c':
-              lf_copy (diff, lenmax, stdout);
-              if (! edit (left, lname, lline, llen,
-                          right, rname, rline, rlen,
-                          outfile))
-                return false;
-              break;
-
-            default:
-              fatal (diff_help);
-            }
-
-          lline += llen;
-          rline += rlen;
-        }
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  llen = val = strtoumax (diff_help + 1, &numend, 10);
+	  if (llen < 0 || llen != val || errno || *numend != ',')
+	    fatal (diff_help);
+	  rlen = val = strtoumax (numend + 1, &numend, 10);
+	  if (rlen < 0 || rlen != val || errno || *numend)
+	    fatal (diff_help);
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
     }
 }
 
@@ -1167,9 +1219,18 @@ temporary_file (void)
   char const *dir = tmpdir ? tmpdir : P_tmpdir;
   char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
   int fd;
+  int e;
+  sigset_t procmask;
+  sigset_t blocked;
   sprintf (buf, "%s/sdiffXXXXXX", dir);
+  sigemptyset (&blocked);
+  sigaddset (&blocked, SIGINT);
+  sigprocmask (SIG_BLOCK, &blocked, &procmask);
   fd = mkstemp (buf);
+  e = errno;
   if (0 <= fd)
     tmpname = buf;
+  sigprocmask (SIG_SETMASK, &procmask, 0);
+  errno = e;
   return fd;
 }
diff -pru diffutils-3.0/side.c diffutils-3.0-patch/side.c
--- diffutils-3.0/side.c	2020-05-30 16:24:16.394920000 -0700
+++ diffutils-3.0-patch/side.c	2020-05-30 15:52:03.075063000 -0700
@@ -1,7 +1,7 @@
 /* sdiff-format output routines for GNU DIFF.
 
-   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2013, 2015-2020 Free
-   Software Foundation, Inc.
+   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2010 Free Software
+   Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -55,8 +55,8 @@ tab_from_to (size_t from, size_t to)
   if (!expand_tabs)
     for (tab = from + tab_size - from % tab_size;  tab <= to;  tab += tab_size)
       {
-        putc ('\t', out);
-        from = tab;
+	putc ('\t', out);
+	from = tab;
       }
   while (from++ < to)
     putc (' ', out);
@@ -83,111 +83,111 @@ print_half_line (char const *const *line
       register char c = *text_pointer++;
 
       switch (c)
-        {
-        case '\t':
-          {
-            size_t spaces = tabsize - in_position % tabsize;
-            if (in_position == out_position)
-              {
-                size_t tabstop = out_position + spaces;
-                if (expand_tabs)
-                  {
-                    if (out_bound < tabstop)
-                      tabstop = out_bound;
-                    for (;  out_position < tabstop;  out_position++)
-                      putc (' ', out);
-                  }
-                else
-                  if (tabstop < out_bound)
-                    {
-                      out_position = tabstop;
-                      putc (c, out);
-                    }
-              }
-            in_position += spaces;
-          }
-          break;
-
-        case '\r':
-          {
-            putc (c, out);
-            tab_from_to (0, indent);
-            in_position = out_position = 0;
-          }
-          break;
-
-        case '\b':
-          if (in_position != 0 && --in_position < out_bound)
-            {
-              if (out_position <= in_position)
-                /* Add spaces to make up for suppressed tab past out_bound.  */
-                for (;  out_position < in_position;  out_position++)
-                  putc (' ', out);
-              else
-                {
-                  out_position = in_position;
-                  putc (c, out);
-                }
-            }
-          break;
-
-        default:
-          {
-            wchar_t wc;
-            size_t bytes = mbrtowc (&wc, tp0, text_limit - tp0, &mbstate);
-
-            if (0 < bytes && bytes < (size_t) -2)
-              {
-                int width = wcwidth (wc);
-                if (0 < width)
-                  in_position += width;
-                if (in_position <= out_bound)
-                  {
-                    out_position = in_position;
-                    fwrite (tp0, 1, bytes, stdout);
-                  }
-                text_pointer = tp0 + bytes;
-                break;
-              }
-          }
-          FALLTHROUGH;
-        case '\f':
-        case '\v':
-          if (in_position < out_bound)
-            putc (c, out);
-          break;
-
-        case ' ': case '!': case '"': case '#': case '%':
-        case '&': case '\'': case '(': case ')': case '*':
-        case '+': case ',': case '-': case '.': case '/':
-        case '0': case '1': case '2': case '3': case '4':
-        case '5': case '6': case '7': case '8': case '9':
-        case ':': case ';': case '<': case '=': case '>':
-        case '?':
-        case 'A': case 'B': case 'C': case 'D': case 'E':
-        case 'F': case 'G': case 'H': case 'I': case 'J':
-        case 'K': case 'L': case 'M': case 'N': case 'O':
-        case 'P': case 'Q': case 'R': case 'S': case 'T':
-        case 'U': case 'V': case 'W': case 'X': case 'Y':
-        case 'Z':
-        case '[': case '\\': case ']': case '^': case '_':
-        case 'a': case 'b': case 'c': case 'd': case 'e':
-        case 'f': case 'g': case 'h': case 'i': case 'j':
-        case 'k': case 'l': case 'm': case 'n': case 'o':
-        case 'p': case 'q': case 'r': case 's': case 't':
-        case 'u': case 'v': case 'w': case 'x': case 'y':
-        case 'z': case '{': case '|': case '}': case '~':
-          /* These characters are printable ASCII characters.  */
-          if (in_position++ < out_bound)
-            {
-              out_position = in_position;
-              putc (c, out);
-            }
-          break;
-
-        case '\n':
-          return out_position;
-        }
+	{
+	case '\t':
+	  {
+	    size_t spaces = tabsize - in_position % tabsize;
+	    if (in_position == out_position)
+	      {
+		size_t tabstop = out_position + spaces;
+		if (expand_tabs)
+		  {
+		    if (out_bound < tabstop)
+		      tabstop = out_bound;
+		    for (;  out_position < tabstop;  out_position++)
+		      putc (' ', out);
+		  }
+		else
+		  if (tabstop < out_bound)
+		    {
+		      out_position = tabstop;
+		      putc (c, out);
+		    }
+	      }
+	    in_position += spaces;
+	  }
+	  break;
+
+	case '\r':
+	  {
+	    putc (c, out);
+	    tab_from_to (0, indent);
+	    in_position = out_position = 0;
+	  }
+	  break;
+
+	case '\b':
+	  if (in_position != 0 && --in_position < out_bound)
+	    {
+	      if (out_position <= in_position)
+		/* Add spaces to make up for suppressed tab past out_bound.  */
+		for (;  out_position < in_position;  out_position++)
+		  putc (' ', out);
+	      else
+		{
+		  out_position = in_position;
+		  putc (c, out);
+		}
+	    }
+	  break;
+
+	default:
+	  {
+	    wchar_t wc;
+	    size_t bytes = mbrtowc (&wc, tp0, text_limit - tp0, &mbstate);
+
+	    if (0 < bytes && bytes < (size_t) -2)
+	      {
+		int width = wcwidth (wc);
+		if (0 < width)
+		  in_position += width;
+		if (in_position <= out_bound)
+		  {
+		    out_position = in_position;
+		    fwrite (tp0, 1, bytes, stdout);
+		  }
+		text_pointer = tp0 + bytes;
+		break;
+	      }
+	  }
+	  /* Fall through.  */
+	case '\f':
+	case '\v':
+	  if (in_position < out_bound)
+	    putc (c, out);
+	  break;
+
+	case ' ': case '!': case '"': case '#': case '%':
+	case '&': case '\'': case '(': case ')': case '*':
+	case '+': case ',': case '-': case '.': case '/':
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+	case ':': case ';': case '<': case '=': case '>':
+	case '?':
+	case 'A': case 'B': case 'C': case 'D': case 'E':
+	case 'F': case 'G': case 'H': case 'I': case 'J':
+	case 'K': case 'L': case 'M': case 'N': case 'O':
+	case 'P': case 'Q': case 'R': case 'S': case 'T':
+	case 'U': case 'V': case 'W': case 'X': case 'Y':
+	case 'Z':
+	case '[': case '\\': case ']': case '^': case '_':
+	case 'a': case 'b': case 'c': case 'd': case 'e':
+	case 'f': case 'g': case 'h': case 'i': case 'j':
+	case 'k': case 'l': case 'm': case 'n': case 'o':
+	case 'p': case 'q': case 'r': case 's': case 't':
+	case 'u': case 'v': case 'w': case 'x': case 'y':
+	case 'z': case '{': case '|': case '}': case '~':
+	  /* These characters are printable ASCII characters.  */
+	  if (in_position++ < out_bound)
+	    {
+	      out_position = in_position;
+	      putc (c, out);
+	    }
+	  break;
+
+	case '\n':
+	  return out_position;
+	}
     }
 
   return out_position;
@@ -199,25 +199,13 @@ print_half_line (char const *const *line
 
 static void
 print_1sdiff_line (char const *const *left, char sep,
-                   char const *const *right)
+		   char const *const *right)
 {
   FILE *out = outfile;
   size_t hw = sdiff_half_width;
   size_t c2o = sdiff_column2_offset;
   size_t col = 0;
   bool put_newline = false;
-  bool color_to_reset = false;
-
-  if (sep == '<')
-    {
-      set_color_context (DELETE_CONTEXT);
-      color_to_reset = true;
-    }
-  else if (sep == '>')
-    {
-      set_color_context (ADD_CONTEXT);
-      color_to_reset = true;
-    }
 
   if (left)
     {
@@ -229,7 +217,7 @@ print_1sdiff_line (char const *const *le
     {
       col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
       if (sep == '|' && put_newline != (right[1][-1] == '\n'))
-        sep = put_newline ? '/' : '\\';
+	sep = put_newline ? '/' : '\\';
       putc (sep, out);
     }
 
@@ -237,17 +225,14 @@ print_1sdiff_line (char const *const *le
     {
       put_newline |= right[1][-1] == '\n';
       if (**right != '\n')
-        {
-          col = tab_from_to (col, c2o);
-          print_half_line (right, col, hw);
-        }
+	{
+	  col = tab_from_to (col, c2o);
+	  print_half_line (right, col, hw);
+	}
     }
 
   if (put_newline)
     putc ('\n', out);
-
-  if (color_to_reset)
-    set_color_context (RESET_CONTEXT);
 }
 
 /* Print lines common to both files in side-by-side format.  */
@@ -259,22 +244,22 @@ print_sdiff_common_lines (lin limit0, li
   if (!suppress_common_lines && (i0 != limit0 || i1 != limit1))
     {
       if (sdiff_merge_assist)
-        {
-          printint len0 = limit0 - i0;
-          printint len1 = limit1 - i1;
-          fprintf (outfile, "i%"pI"d,%"pI"d\n", len0, len1);
-        }
+	{
+	  long int len0 = limit0 - i0;
+	  long int len1 = limit1 - i1;
+	  fprintf (outfile, "i%ld,%ld\n", len0, len1);
+	}
 
       if (!left_column)
-        {
-          while (i0 != limit0 && i1 != limit1)
-            print_1sdiff_line (&files[0].linbuf[i0++], ' ',
-                               &files[1].linbuf[i1++]);
-          while (i1 != limit1)
-            print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
-        }
+	{
+	  while (i0 != limit0 && i1 != limit1)
+	    print_1sdiff_line (&files[0].linbuf[i0++], ' ',
+			       &files[1].linbuf[i1++]);
+	  while (i1 != limit1)
+	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
+	}
       while (i0 != limit0)
-        print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
+	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
     }
 
   next0 = limit0;
@@ -302,16 +287,16 @@ print_sdiff_hunk (struct change *hunk)
 
   if (sdiff_merge_assist)
     {
-      printint len0 = last0 - first0 + 1;
-      printint len1 = last1 - first1 + 1;
-      fprintf (outfile, "c%"pI"d,%"pI"d\n", len0, len1);
+      long int len0 = last0 - first0 + 1;
+      long int len1 = last1 - first1 + 1;
+      fprintf (outfile, "c%ld,%ld\n", len0, len1);
     }
 
   /* Print "xxx  |  xxx " lines.  */
   if (changes == CHANGED)
     {
       for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
-        print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
+	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
       changes = (i <= last0 ? OLD : 0) + (j <= last1 ? NEW : 0);
       next0 = first0 = i;
       next1 = first1 = j;
@@ -321,15 +306,15 @@ print_sdiff_hunk (struct change *hunk)
   if (changes & NEW)
     {
       for (j = first1; j <= last1; ++j)
-        print_1sdiff_line (0, '>', &files[1].linbuf[j]);
+	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
       next1 = j;
     }
 
-  /* Print "xxx  <     " lines.  */
+  /* Print ``xxx  <     '' lines */
   if (changes & OLD)
     {
       for (i = first0; i <= last0; ++i)
-        print_1sdiff_line (&files[0].linbuf[i], '<', 0);
+	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
       next0 = i;
     }
 }
diff -pru diffutils-3.0/util.c diffutils-3.0-patch/util.c
--- diffutils-3.0/util.c	2020-05-30 16:24:16.396918000 -0700
+++ diffutils-3.0-patch/util.c	2020-05-30 15:52:03.077063000 -0700
@@ -1,7 +1,7 @@
 /* Support routines for GNU DIFF.
 
-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
-   2015-2020 Free Software Foundation, Inc.
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
 
    This file is part of GNU DIFF.
 
@@ -19,29 +19,10 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 #include "diff.h"
-#include "argmatch.h"
-#include "die.h"
 #include <dirname.h>
 #include <error.h>
-#include <system-quote.h>
+#include <sh-quote.h>
 #include <xalloc.h>
-#include "xvasprintf.h"
-#include <signal.h>
-
-/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
-   present.  */
-#ifndef SA_NOCLDSTOP
-# define SA_NOCLDSTOP 0
-# define sigprocmask(How, Set, Oset) /* empty */
-# define sigset_t int
-# if ! HAVE_SIGINTERRUPT
-#  define siginterrupt(sig, flag) /* empty */
-# endif
-#endif
-
-#ifndef SA_RESTART
-# define SA_RESTART 0
-#endif
 
 char const pr_program[] = PR_PROGRAM;
 
@@ -78,7 +59,8 @@ pfatal_with_name (char const *name)
 {
   int e = errno;
   print_message_queue ();
-  die (EXIT_TROUBLE, e, "%s", name);
+  error (EXIT_TROUBLE, e, "%s", name);
+  abort ();
 }
 
 /* Print an error message containing MSGID, then exit.  */
@@ -87,7 +69,8 @@ void
 fatal (char const *msgid)
 {
   print_message_queue ();
-  die (EXIT_TROUBLE, 0, "%s", _(msgid));
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
 }
 
 /* Like printf, except if -l in effect then save the message and print later.
@@ -101,7 +84,7 @@ message (char const *format_msgid, char
 
 void
 message5 (char const *format_msgid, char const *arg1, char const *arg2,
-          char const *arg3, char const *arg4)
+	  char const *arg3, char const *arg4)
 {
   if (paginate)
     {
@@ -119,12 +102,12 @@ message5 (char const *format_msgid, char
       arg[4] = arg4 ? arg4 : "";
 
       for (i = 0;  i < 5;  i++)
-        total_size += size[i] = strlen (arg[i]) + 1;
+	total_size += size[i] = strlen (arg[i]) + 1;
 
       new = xmalloc (total_size);
 
       for (i = 0, p = new->args;  i < 5;  p += size[i++])
-        memcpy (p, arg[i], size[i]);
+	memcpy (p, arg[i], size[i]);
 
       *msg_chain_end = new;
       new->next = 0;
@@ -133,7 +116,7 @@ message5 (char const *format_msgid, char
   else
     {
       if (sdiff_merge_assist)
-        putchar (' ');
+	putchar (' ');
       printf (_(format_msgid), arg1, arg2, arg3, arg4);
     }
 }
@@ -152,581 +135,23 @@ print_message_queue (void)
       struct msg *next = m->next;
       arg[0] = m->args;
       for (i = 0;  i < 4;  i++)
-        arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
       printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
       free (m);
       m = next;
     }
 }
 
-/* The set of signals that are caught.  */
-
-static sigset_t caught_signals;
-
-/* If nonzero, the value of the pending fatal signal.  */
-
-static sig_atomic_t volatile interrupt_signal;
-
-/* A count of the number of pending stop signals that have been received.  */
-
-static sig_atomic_t volatile stop_signal_count;
-
-/* An ordinary signal was received; arrange for the program to exit.  */
-
-static void
-sighandler (int sig)
-{
-  if (! SA_NOCLDSTOP)
-    signal (sig, SIG_IGN);
-  if (! interrupt_signal)
-    interrupt_signal = sig;
-}
-
-/* A SIGTSTP was received; arrange for the program to suspend itself.  */
-
-static void
-stophandler (int sig)
-{
-  if (! SA_NOCLDSTOP)
-    signal (sig, stophandler);
-  if (! interrupt_signal)
-    stop_signal_count++;
-}
-/* Process any pending signals.  If signals are caught, this function
-   should be called periodically.  Ideally there should never be an
-   unbounded amount of time when signals are not being processed.
-   Signal handling can restore the default colors, so callers must
-   immediately change colors after invoking this function.  */
-
-static void
-process_signals (void)
-{
-  while (interrupt_signal || stop_signal_count)
-    {
-      int sig;
-      int stops;
-      sigset_t oldset;
-
-      set_color_context (RESET_CONTEXT);
-      fflush (stdout);
-
-      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
-
-      /* Reload interrupt_signal and stop_signal_count, in case a new
-         signal was handled before sigprocmask took effect.  */
-      sig = interrupt_signal;
-      stops = stop_signal_count;
-
-      /* SIGTSTP is special, since the application can receive that signal
-         more than once.  In this case, don't set the signal handler to the
-         default.  Instead, just raise the uncatchable SIGSTOP.  */
-      if (stops)
-        {
-          stop_signal_count = stops - 1;
-          sig = SIGSTOP;
-        }
-      else
-        signal (sig, SIG_DFL);
-
-      /* Exit or suspend the program.  */
-      raise (sig);
-      sigprocmask (SIG_SETMASK, &oldset, NULL);
-
-      /* If execution reaches here, then the program has been
-         continued (after being suspended).  */
-    }
-}
-
-static void
-install_signal_handlers (void)
-{
-  /* The signals that are trapped, and the number of such signals.  */
-  static int const sig[] =
-    {
-      /* This one is handled specially.  */
-      SIGTSTP,
-
-      /* The usual suspects.  */
-      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
-#ifdef SIGPOLL
-      SIGPOLL,
-#endif
-#ifdef SIGPROF
-      SIGPROF,
-#endif
-#ifdef SIGVTALRM
-      SIGVTALRM,
-#endif
-#ifdef SIGXCPU
-      SIGXCPU,
-#endif
-#ifdef SIGXFSZ
-      SIGXFSZ,
-#endif
-    };
-  enum { nsigs = sizeof (sig) / sizeof *(sig) };
-
-#if ! SA_NOCLDSTOP
-  bool caught_sig[nsigs];
-#endif
-  {
-    int j;
-#if SA_NOCLDSTOP
-    struct sigaction act;
-
-    sigemptyset (&caught_signals);
-    for (j = 0; j < nsigs; j++)
-      {
-        sigaction (sig[j], NULL, &act);
-        if (act.sa_handler != SIG_IGN)
-          sigaddset (&caught_signals, sig[j]);
-      }
-
-    act.sa_mask = caught_signals;
-    act.sa_flags = SA_RESTART;
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
 
-    for (j = 0; j < nsigs; j++)
-      if (sigismember (&caught_signals, sig[j]))
-        {
-          act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
-          sigaction (sig[j], &act, NULL);
-        }
-#else
-    for (j = 0; j < nsigs; j++)
-      {
-        caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
-        if (caught_sig[j])
-          {
-            signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
-            siginterrupt (sig[j], 0);
-          }
-      }
-#endif
-    }
-}
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a `pr' and make OUTFILE a pipe to it.
+   `pr' then outputs to our stdout.  */
 
 static char const *current_name0;
 static char const *current_name1;
 static bool currently_recursive;
-static bool colors_enabled;
-
-static struct color_ext_type *color_ext_list = NULL;
-
-struct bin_str
-  {
-    size_t len;			/* Number of bytes */
-    const char *string;		/* Pointer to the same */
-  };
-
-struct color_ext_type
-  {
-    struct bin_str ext;		/* The extension we're looking for */
-    struct bin_str seq;		/* The sequence to output when we do */
-    struct color_ext_type *next;	/* Next in list */
-  };
-
-/* Parse a string as part of the --palette argument; this may involve
-   decoding all kinds of escape characters.  If equals_end is set an
-   unescaped equal sign ends the string, otherwise only a : or \0
-   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
-   true if successful.
-
-   The resulting string is *not* null-terminated, but may contain
-   embedded nulls.
-
-   Note that both dest and src are char **; on return they point to
-   the first free byte after the array and the character that ended
-   the input string, respectively.  */
-
-static bool
-get_funky_string (char **dest, const char **src, bool equals_end,
-                  size_t *output_count)
-{
-  char num;			/* For numerical codes */
-  size_t count;			/* Something to count with */
-  enum {
-    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
-  } state;
-  const char *p;
-  char *q;
-
-  p = *src;			/* We don't want to double-indirect */
-  q = *dest;			/* the whole darn time.  */
-
-  count = 0;			/* No characters counted in yet.  */
-  num = 0;
-
-  state = ST_GND;		/* Start in ground state.  */
-  while (state < ST_END)
-    {
-      switch (state)
-        {
-        case ST_GND:		/* Ground state (no escapes) */
-          switch (*p)
-            {
-            case ':':
-            case '\0':
-              state = ST_END;	/* End of string */
-              break;
-            case '\\':
-              state = ST_BACKSLASH; /* Backslash scape sequence */
-              ++p;
-              break;
-            case '^':
-              state = ST_CARET; /* Caret escape */
-              ++p;
-              break;
-            case '=':
-              if (equals_end)
-                {
-                  state = ST_END; /* End */
-                  break;
-                }
-              FALLTHROUGH;
-            default:
-              *(q++) = *(p++);
-              ++count;
-              break;
-            }
-          break;
-
-        case ST_BACKSLASH:	/* Backslash escaped character */
-          switch (*p)
-            {
-            case '0':
-            case '1':
-            case '2':
-            case '3':
-            case '4':
-            case '5':
-            case '6':
-            case '7':
-              state = ST_OCTAL;	/* Octal sequence */
-              num = *p - '0';
-              break;
-            case 'x':
-            case 'X':
-              state = ST_HEX;	/* Hex sequence */
-              num = 0;
-              break;
-            case 'a':		/* Bell */
-              num = '\a';
-              break;
-            case 'b':		/* Backspace */
-              num = '\b';
-              break;
-            case 'e':		/* Escape */
-              num = 27;
-              break;
-            case 'f':		/* Form feed */
-              num = '\f';
-              break;
-            case 'n':		/* Newline */
-              num = '\n';
-              break;
-            case 'r':		/* Carriage return */
-              num = '\r';
-              break;
-            case 't':		/* Tab */
-              num = '\t';
-              break;
-            case 'v':		/* Vtab */
-              num = '\v';
-              break;
-            case '?':		/* Delete */
-              num = 127;
-              break;
-            case '_':		/* Space */
-              num = ' ';
-              break;
-            case '\0':		/* End of string */
-              state = ST_ERROR;	/* Error! */
-              break;
-            default:		/* Escaped character like \ ^ : = */
-              num = *p;
-              break;
-            }
-          if (state == ST_BACKSLASH)
-            {
-              *(q++) = num;
-              ++count;
-              state = ST_GND;
-            }
-          ++p;
-          break;
-
-        case ST_OCTAL:		/* Octal sequence */
-          if (*p < '0' || *p > '7')
-            {
-              *(q++) = num;
-              ++count;
-              state = ST_GND;
-            }
-          else
-            num = (num << 3) + (*(p++) - '0');
-          break;
-
-        case ST_HEX:		/* Hex sequence */
-          switch (*p)
-            {
-            case '0':
-            case '1':
-            case '2':
-            case '3':
-            case '4':
-            case '5':
-            case '6':
-            case '7':
-            case '8':
-            case '9':
-              num = (num << 4) + (*(p++) - '0');
-              break;
-            case 'a':
-            case 'b':
-            case 'c':
-            case 'd':
-            case 'e':
-            case 'f':
-              num = (num << 4) + (*(p++) - 'a') + 10;
-              break;
-            case 'A':
-            case 'B':
-            case 'C':
-            case 'D':
-            case 'E':
-            case 'F':
-              num = (num << 4) + (*(p++) - 'A') + 10;
-              break;
-            default:
-              *(q++) = num;
-              ++count;
-              state = ST_GND;
-              break;
-            }
-          break;
-
-        case ST_CARET:		/* Caret escape */
-          state = ST_GND;	/* Should be the next state... */
-          if (*p >= '@' && *p <= '~')
-            {
-              *(q++) = *(p++) & 037;
-              ++count;
-            }
-          else if (*p == '?')
-            {
-              *(q++) = 127;
-              ++count;
-            }
-          else
-            state = ST_ERROR;
-          break;
-
-        default:
-          abort ();
-        }
-    }
-
-  *dest = q;
-  *src = p;
-  *output_count = count;
-
-  return state != ST_ERROR;
-}
-
-enum parse_state
-  {
-    PS_START = 1,
-    PS_2,
-    PS_3,
-    PS_4,
-    PS_DONE,
-    PS_FAIL
-  };
-
-#define LEN_STR_PAIR(s) sizeof (s) - 1, s
-
-static struct bin_str color_indicator[] =
-  {
-    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
-    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
-    { 0, NULL },			/* ec: End color (replaces lc+rs+rc) */
-    { LEN_STR_PAIR ("0") },		/* rs: Reset to ordinary colors */
-    { LEN_STR_PAIR ("1") },		/* hd: Header */
-    { LEN_STR_PAIR ("32") },		/* ad: Add line */
-    { LEN_STR_PAIR ("31") },		/* de: Delete line */
-    { LEN_STR_PAIR ("36") },		/* ln: Line number */
-  };
-
-static const char *const indicator_name[] =
-  {
-    "lc", "rc", "ec", "rs", "hd", "ad", "de", "ln", NULL
-  };
-ARGMATCH_VERIFY (indicator_name, color_indicator);
-
-static char const *color_palette;
-
-void
-set_color_palette (char const *palette)
-{
-  color_palette = palette;
-}
-
-static void
-parse_diff_color (void)
-{
-  char *color_buf;
-  const char *p;		/* Pointer to character being parsed */
-  char *buf;			/* color_buf buffer pointer */
-  int ind_no;			/* Indicator number */
-  char label[3];		/* Indicator label */
-  struct color_ext_type *ext;	/* Extension we are working on */
-
-  if ((p = color_palette) == NULL || *p == '\0')
-    return;
-
-  ext = NULL;
-  strcpy (label, "??");
-
-  /* This is an overly conservative estimate, but any possible
-     --palette string will *not* generate a color_buf longer than
-     itself, so it is a safe way of allocating a buffer in
-     advance.  */
-  buf = color_buf = xstrdup (p);
-
-  enum parse_state state = PS_START;
-  while (true)
-    {
-      switch (state)
-        {
-        case PS_START:		/* First label character */
-          switch (*p)
-            {
-            case ':':
-              ++p;
-              break;
-
-            case '*':
-              /* Allocate new extension block and add to head of
-                 linked list (this way a later definition will
-                 override an earlier one, which can be useful for
-                 having terminal-specific defs override global).  */
-
-              ext = xmalloc (sizeof *ext);
-              ext->next = color_ext_list;
-              color_ext_list = ext;
-
-              ++p;
-              ext->ext.string = buf;
-
-              state = (get_funky_string (&buf, &p, true, &ext->ext.len)
-                       ? PS_4 : PS_FAIL);
-              break;
-
-            case '\0':
-              state = PS_DONE;	/* Done! */
-              goto done;
-
-            default:	/* Assume it is file type label */
-              label[0] = *(p++);
-              state = PS_2;
-              break;
-            }
-          break;
-
-        case PS_2:		/* Second label character */
-          if (*p)
-            {
-              label[1] = *(p++);
-              state = PS_3;
-            }
-          else
-            state = PS_FAIL;	/* Error */
-          break;
-
-        case PS_3:		/* Equal sign after indicator label */
-          state = PS_FAIL;	/* Assume failure...  */
-          if (*(p++) == '=')/* It *should* be...  */
-            {
-              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
-                {
-                  if (STREQ (label, indicator_name[ind_no]))
-                    {
-                      color_indicator[ind_no].string = buf;
-                      state = (get_funky_string (&buf, &p, false,
-                                                 &color_indicator[ind_no].len)
-                               ? PS_START : PS_FAIL);
-                      break;
-                    }
-                }
-              if (state == PS_FAIL)
-                error (0, 0, _("unrecognized prefix: %s"), label);
-            }
-          break;
-
-        case PS_4:		/* Equal sign after *.ext */
-          if (*(p++) == '=')
-            {
-              ext->seq.string = buf;
-              state = (get_funky_string (&buf, &p, false, &ext->seq.len)
-                       ? PS_START : PS_FAIL);
-            }
-          else
-            state = PS_FAIL;
-          break;
-
-        case PS_FAIL:
-          goto done;
-
-        default:
-          abort ();
-        }
-    }
- done:
-
-  if (state == PS_FAIL)
-    {
-      struct color_ext_type *e;
-      struct color_ext_type *e2;
-
-      error (0, 0,
-             _("unparsable value for --palette"));
-      free (color_buf);
-      for (e = color_ext_list; e != NULL; /* empty */)
-        {
-          e2 = e;
-          e = e->next;
-          free (e2);
-        }
-      colors_enabled = false;
-    }
-}
-
-static void
-check_color_output (bool is_pipe)
-{
-  bool output_is_tty;
-
-  if (! outfile || colors_style == NEVER)
-    return;
-
-  output_is_tty = presume_output_tty || (!is_pipe && isatty (fileno (outfile)));
-
-  colors_enabled = (colors_style == ALWAYS
-                    || (colors_style == AUTO && output_is_tty));
-
-  if (colors_enabled)
-    parse_diff_color ();
-
-  if (output_is_tty)
-    install_signal_handlers ();
-}
-
-/* Call before outputting the results of comparing files NAME0 and NAME1
-   to set up OUTFILE, the stdio stream for the output to go to.
-
-   Usually, OUTFILE is just stdout.  But when -l was specified
-   we fork off a 'pr' and make OUTFILE a pipe to it.
-   'pr' then outputs to our stdout.  */
 
 void
 setup_output (char const *name0, char const *name1, bool recursive)
@@ -737,166 +162,79 @@ setup_output (char const *name0, char co
   outfile = 0;
 }
 
-#if HAVE_WORKING_FORK
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
 static pid_t pr_pid;
 #endif
 
-static char c_escape_char (char c)
-{
-  switch (c) {
-    case '\a': return 'a';
-    case '\b': return 'b';
-    case '\t': return 't';
-    case '\n': return 'n';
-    case '\v': return 'v';
-    case '\f': return 'f';
-    case '\r': return 'r';
-    case '"': return '"';
-    case '\\': return '\\';
-    default:
-      return c < 32;
-  }
-}
-
-static char *
-c_escape (char const *str)
-{
-  char const *s;
-  size_t plus = 0;
-  bool must_quote = false;
-
-  for (s = str; *s; s++)
-    {
-      char c = *s;
-
-      if (c == ' ')
-        {
-          must_quote = true;
-          continue;
-        }
-      switch (c_escape_char (*s))
-        {
-          case 1:
-            plus += 3;
-            /* fall through */
-          case 0:
-            break;
-          default:
-            plus++;
-            break;
-        }
-    }
-
-  if (must_quote || plus)
-    {
-      size_t s_len = s - str;
-      char *buffer = xmalloc (s_len + plus + 3);
-      char *b = buffer;
-
-      *b++ = '"';
-      for (s = str; *s; s++)
-        {
-          char c = *s;
-          char escape = c_escape_char (c);
-
-          switch (escape)
-            {
-              case 0:
-                *b++ = c;
-                break;
-              case 1:
-                *b++ = '\\';
-                *b++ = ((c >> 6) & 03) + '0';
-                *b++ = ((c >> 3) & 07) + '0';
-                *b++ = ((c >> 0) & 07) + '0';
-                break;
-              default:
-                *b++ = '\\';
-                *b++ = escape;
-                break;
-            }
-        }
-      *b++ = '"';
-      *b = 0;
-      return buffer;
-    }
-
-  return (char *) str;
-}
-
 void
 begin_output (void)
 {
-  char *names[2];
   char *name;
 
   if (outfile != 0)
     return;
 
-  names[0] = c_escape (current_name0);
-  names[1] = c_escape (current_name1);
-
   /* Construct the header of this piece of diff.  */
+  name = xmalloc (strlen (current_name0) + strlen (current_name1)
+		  + strlen (switch_string) + 7);
+
   /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
      the standard: it says that we must print only the last component
      of the pathnames, and it requires two spaces after "diff" if
      there are no options.  These requirements are silly and do not
      match historical practice.  */
-  name = xasprintf ("diff%s %s %s", switch_string, names[0], names[1]);
+  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
 
   if (paginate)
     {
-      char const *argv[4];
-
       if (fflush (stdout) != 0)
-        pfatal_with_name (_("write failed"));
-
-      argv[0] = pr_program;
-      argv[1] = "-h";
-      argv[2] = name;
-      argv[3] = 0;
+	pfatal_with_name (_("write failed"));
 
       /* Make OUTFILE a pipe to a subsidiary 'pr'.  */
       {
-#if HAVE_WORKING_FORK
-        int pipes[2];
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+	int pipes[2];
 
-        if (pipe (pipes) != 0)
-          pfatal_with_name ("pipe");
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
 
-        pr_pid = fork ();
-        if (pr_pid < 0)
-          pfatal_with_name ("fork");
-
-        if (pr_pid == 0)
-          {
-            close (pipes[1]);
-            if (pipes[0] != STDIN_FILENO)
-              {
-                if (dup2 (pipes[0], STDIN_FILENO) < 0)
-                  pfatal_with_name ("dup2");
-                close (pipes[0]);
-              }
-
-            execv (pr_program, (char **) argv);
-            _exit (errno == ENOENT ? 127 : 126);
-          }
-        else
-          {
-            close (pipes[0]);
-            outfile = fdopen (pipes[1], "w");
-            if (!outfile)
-              pfatal_with_name ("fdopen");
-            check_color_output (true);
-          }
+	pr_pid = vfork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	  }
 #else
-        char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
-        errno = 0;
-        outfile = popen (command, "w");
-        if (!outfile)
-          pfatal_with_name (command);
-        check_color_output (true);
-        free (command);
+	char *command = xmalloc (sizeof pr_program - 1 + 7
+				 + shell_quote_length (name) + 1);
+	char *p;
+	sprintf (command, "%s -f -h ", pr_program);
+	p = command + sizeof pr_program - 1 + 7;
+	p = shell_quote_copy (p, name);
+	*p = 0;
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	free (command);
 #endif
       }
     }
@@ -906,12 +244,11 @@ begin_output (void)
       /* If -l was not specified, output the diff straight to 'stdout'.  */
 
       outfile = stdout;
-      check_color_output (false);
 
       /* If handling multiple files (because scanning a directory),
-         print which files the following output is about.  */
+	 print which files the following output is about.  */
       if (currently_recursive)
-        printf ("%s\n", name);
+	printf ("%s\n", name);
     }
 
   free (name);
@@ -920,21 +257,16 @@ begin_output (void)
   switch (output_style)
     {
     case OUTPUT_CONTEXT:
-      print_context_header (files, (char const *const *)names, false);
+      print_context_header (files, false);
       break;
 
     case OUTPUT_UNIFIED:
-      print_context_header (files, (char const *const *)names, true);
+      print_context_header (files, true);
       break;
 
     default:
       break;
     }
-
-  if (names[0] != current_name0)
-    free (names[0]);
-  if (names[1] != current_name1)
-    free (names[1]);
 }
 
 /* Call after the end of output of diffs for one file.
@@ -949,30 +281,30 @@ finish_output (void)
       int wstatus;
       int werrno = 0;
       if (ferror (outfile))
-        fatal ("write failed");
-#if ! HAVE_WORKING_FORK
+	fatal ("write failed");
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
       wstatus = pclose (outfile);
       if (wstatus == -1)
-        werrno = errno;
+	werrno = errno;
 #else
       if (fclose (outfile) != 0)
-        pfatal_with_name (_("write failed"));
+	pfatal_with_name (_("write failed"));
       if (waitpid (pr_pid, &wstatus, 0) < 0)
-        pfatal_with_name ("waitpid");
+	pfatal_with_name ("waitpid");
 #endif
       status = (! werrno && WIFEXITED (wstatus)
-                ? WEXITSTATUS (wstatus)
-                : INT_MAX);
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
       if (status)
-        die (EXIT_TROUBLE, werrno,
-               _(status == 126
-                 ? "subsidiary program '%s' could not be invoked"
-                 : status == 127
-                 ? "subsidiary program '%s' not found"
-                 : status == INT_MAX
-                 ? "subsidiary program '%s' failed"
-                 : "subsidiary program '%s' failed (exit status %d)"),
-               pr_program, status);
+	error (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program '%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program '%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
+	       pr_program, status);
     }
 
   outfile = 0;
@@ -998,143 +330,116 @@ lines_differ (char const *s1, char const
 
       /* Test for exact char equality first, since it's a common case.  */
       if (c1 != c2)
-        {
-          switch (ignore_white_space)
-            {
-            case IGNORE_ALL_SPACE:
-              /* For -w, just skip past any white space.  */
-              while (isspace (c1) && c1 != '\n') c1 = *t1++;
-              while (isspace (c2) && c2 != '\n') c2 = *t2++;
-              break;
-
-            case IGNORE_SPACE_CHANGE:
-              /* For -b, advance past any sequence of white space in
-                 line 1 and consider it just one space, or nothing at
-                 all if it is at the end of the line.  */
-              if (isspace (c1))
-                {
-                  while (c1 != '\n')
-                    {
-                      c1 = *t1++;
-                      if (! isspace (c1))
-                        {
-                          --t1;
-                          c1 = ' ';
-                          break;
-                        }
-                    }
-                }
-
-              /* Likewise for line 2.  */
-              if (isspace (c2))
-                {
-                  while (c2 != '\n')
-                    {
-                      c2 = *t2++;
-                      if (! isspace (c2))
-                        {
-                          --t2;
-                          c2 = ' ';
-                          break;
-                        }
-                    }
-                }
-
-              if (c1 != c2)
-                {
-                  /* If we went too far when doing the simple test
-                     for equality, go back to the first non-white-space
-                     character in both sides and try again.  */
-                  if (c2 == ' ' && c1 != '\n'
-                      && s1 + 1 < t1
-                      && isspace ((unsigned char) t1[-2]))
-                    {
-                      --t1;
-                      continue;
-                    }
-                  if (c1 == ' ' && c2 != '\n'
-                      && s2 + 1 < t2
-                      && isspace ((unsigned char) t2[-2]))
-                    {
-                      --t2;
-                      continue;
-                    }
-                }
-
-              break;
-
-            case IGNORE_TRAILING_SPACE:
-            case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
-              if (isspace (c1) && isspace (c2))
-                {
-                  unsigned char c;
-                  if (c1 != '\n')
-                    {
-                      char const *p = t1;
-                      while ((c = *p) != '\n' && isspace (c))
-                        ++p;
-                      if (c != '\n')
-                        break;
-                    }
-                  if (c2 != '\n')
-                    {
-                      char const *p = t2;
-                      while ((c = *p) != '\n' && isspace (c))
-                        ++p;
-                      if (c != '\n')
-                        break;
-                    }
-                  /* Both lines have nothing but whitespace left.  */
-                  return false;
-                }
-              if (ignore_white_space == IGNORE_TRAILING_SPACE)
-                break;
-              FALLTHROUGH;
-            case IGNORE_TAB_EXPANSION:
-              if ((c1 == ' ' && c2 == '\t')
-                  || (c1 == '\t' && c2 == ' '))
-                {
-                  size_t column2 = column;
-                  for (;; c1 = *t1++)
-                    {
-                      if (c1 == ' ')
-                        column++;
-                      else if (c1 == '\t')
-                        column += tabsize - column % tabsize;
-                      else
-                        break;
-                    }
-                  for (;; c2 = *t2++)
-                    {
-                      if (c2 == ' ')
-                        column2++;
-                      else if (c2 == '\t')
-                        column2 += tabsize - column2 % tabsize;
-                      else
-                        break;
-                    }
-                  if (column != column2)
-                    return true;
-                }
-              break;
-
-            case IGNORE_NO_WHITE_SPACE:
-              break;
-            }
-
-          /* Lowercase all letters if -i is specified.  */
-
-          if (ignore_case)
-            {
-              c1 = tolower (c1);
-              c2 = tolower (c2);
-            }
-
-          if (c1 != c2)
-            break;
-        }
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
       if (c1 == '\n')
-        return false;
+	return false;
 
       column += c1 == '\t' ? tabsize - column % tabsize : 1;
     }
@@ -1145,13 +450,13 @@ lines_differ (char const *s1, char const
 /* Find the consecutive changes at the start of the script START.
    Return the last link before the first gap.  */
 
-struct change * _GL_ATTRIBUTE_CONST
+struct change *
 find_change (struct change *start)
 {
   return start;
 }
 
-struct change * _GL_ATTRIBUTE_CONST
+struct change *
 find_reverse_change (struct change *start)
 {
   return start;
@@ -1170,8 +475,8 @@ find_reverse_change (struct change *star
 
 void
 print_script (struct change *script,
-              struct change * (*hunkfun) (struct change *),
-              void (*printfun) (struct change *))
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
 {
   struct change *next = script;
 
@@ -1184,7 +489,7 @@ print_script (struct change *script,
       end = (*hunkfun) (next);
 
       /* Disconnect them from the rest of the changes,
-         making them a hunk, and remember the rest for next iteration.  */
+	 making them a hunk, and remember the rest for next iteration.  */
       next = end->link;
       end->link = 0;
 #ifdef DEBUG
@@ -1207,18 +512,6 @@ print_script (struct change *script,
 void
 print_1_line (char const *line_flag, char const *const *line)
 {
-  print_1_line_nl (line_flag, line, false);
-}
-
-/* Print the text of a single line LINE,
-   flagging it with the characters in LINE_FLAG (which say whether
-   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
-   end in a blank, unless it is a single blank.  If SKIP_NL is set, then
-   the final '\n' is not printed.  */
-
-void
-print_1_line_nl (char const *line_flag, char const *const *line, bool skip_nl)
-{
   char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
   FILE *out = outfile; /* Help the compiler some more.  */
   char const *flag_format = 0;
@@ -1234,25 +527,22 @@ print_1_line_nl (char const *line_flag,
       char const *line_flag_1 = line_flag;
 
       if (suppress_blank_empty && **line == '\n')
-        {
-          flag_format_1 = "%s";
+	{
+	  flag_format_1 = "%s";
 
-          /* This hack to omit trailing blanks takes advantage of the
-             fact that the only way that LINE_FLAG can end in a blank
-             is when LINE_FLAG consists of a single blank.  */
-          line_flag_1 += *line_flag_1 == ' ';
-        }
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
 
       fprintf (out, flag_format_1, line_flag_1);
     }
 
-  output_1_line (base, limit - (skip_nl && limit[-1] == '\n'), flag_format, line_flag);
+  output_1_line (base, limit, flag_format, line_flag);
 
   if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
-    {
-      set_color_context (RESET_CONTEXT);
-      fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
-    }
+    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
 }
 
 /* Output a line from BASE up to LIMIT.
@@ -1262,23 +552,10 @@ print_1_line_nl (char const *line_flag,
 
 void
 output_1_line (char const *base, char const *limit, char const *flag_format,
-               char const *line_flag)
+	       char const *line_flag)
 {
-  const size_t MAX_CHUNK = 1024;
   if (!expand_tabs)
-    {
-      size_t left = limit - base;
-      while (left)
-        {
-          size_t to_write = MIN (left, MAX_CHUNK);
-          size_t written = fwrite (base, sizeof (char), to_write, outfile);
-          if (written < to_write)
-            return;
-          base += written;
-          left -= written;
-          process_signals ();
-        }
-    }
+    fwrite (base, sizeof (char), limit - base, outfile);
   else
     {
       register FILE *out = outfile;
@@ -1286,104 +563,42 @@ output_1_line (char const *base, char co
       register char const *t = base;
       register size_t column = 0;
       size_t tab_size = tabsize;
-      size_t counter_proc_signals = 0;
 
       while (t < limit)
-        {
-          counter_proc_signals++;
-          if (counter_proc_signals == MAX_CHUNK)
-            {
-              process_signals ();
-              counter_proc_signals = 0;
-            }
-
-          switch ((c = *t++))
-            {
-            case '\t':
-              {
-                size_t spaces = tab_size - column % tab_size;
-                column += spaces;
-                do
-                  putc (' ', out);
-                while (--spaces);
-              }
-              break;
-
-            case '\r':
-              putc (c, out);
-              if (flag_format && t < limit && *t != '\n')
-                fprintf (out, flag_format, line_flag);
-              column = 0;
-              break;
-
-            case '\b':
-              if (column == 0)
-                continue;
-              column--;
-              putc (c, out);
-              break;
-
-            default:
-              column += isprint (c) != 0;
-              putc (c, out);
-              break;
-            }
-        }
-    }
-}
-
-enum indicator_no
-  {
-    C_LEFT, C_RIGHT, C_END, C_RESET, C_HEADER, C_ADD, C_DELETE, C_LINE
-  };
-
-static void
-put_indicator (const struct bin_str *ind)
-{
-  fwrite (ind->string, ind->len, 1, outfile);
-}
-
-static enum color_context last_context = RESET_CONTEXT;
-
-void
-set_color_context (enum color_context color_context)
-{
-  if (color_context != RESET_CONTEXT)
-    process_signals ();
-  if (colors_enabled && last_context != color_context)
-    {
-      put_indicator (&color_indicator[C_LEFT]);
-      switch (color_context)
-        {
-        case HEADER_CONTEXT:
-          put_indicator (&color_indicator[C_HEADER]);
-          break;
-
-        case LINE_NUMBER_CONTEXT:
-          put_indicator (&color_indicator[C_LINE]);
-          break;
-
-        case ADD_CONTEXT:
-          put_indicator (&color_indicator[C_ADD]);
-          break;
-
-        case DELETE_CONTEXT:
-          put_indicator (&color_indicator[C_DELETE]);
-          break;
-
-        case RESET_CONTEXT:
-          put_indicator (&color_indicator[C_RESET]);
-          break;
-
-        default:
-          abort ();
-        }
-      put_indicator (&color_indicator[C_RIGHT]);
-      last_context = color_context;
+	switch ((c = *t++))
+	  {
+	  case '\t':
+	    {
+	      size_t spaces = tab_size - column % tab_size;
+	      column += spaces;
+	      do
+		putc (' ', out);
+	      while (--spaces);
+	    }
+	    break;
+
+	  case '\r':
+	    putc (c, out);
+	    if (flag_format && t < limit && *t != '\n')
+	      fprintf (out, flag_format, line_flag);
+	    column = 0;
+	    break;
+
+	  case '\b':
+	    if (column == 0)
+	      continue;
+	    column--;
+	    putc (c, out);
+	    break;
+
+	  default:
+	    column += isprint (c) != 0;
+	    putc (c, out);
+	    break;
+	  }
     }
 }
 
-
 char const change_letter[] = { 0, 'd', 'a', 'c' };
 
 /* Translate an internal line number (an index into diff's table of lines)
@@ -1393,20 +608,20 @@ char const change_letter[] = { 0, 'd', '
    Internal line numbers count from 0 starting after the prefix.
    Actual line numbers count from 1 within the entire file.  */
 
-lin _GL_ATTRIBUTE_PURE
+lin
 translate_line_number (struct file_data const *file, lin i)
 {
   return i + file->prefix_lines + 1;
 }
 
 /* Translate a line number range.  This is always done for printing,
-   so for convenience translate to printint rather than lin, so that the
-   caller can use printf with "%"pI"d" without casting.  */
+   so for convenience translate to long int rather than lin, so that the
+   caller can use printf with "%ld" without casting.  */
 
 void
 translate_range (struct file_data const *file,
-                 lin a, lin b,
-                 printint *aptr, printint *bptr)
+		 lin a, lin b,
+		 long int *aptr, long int *bptr)
 {
   *aptr = translate_line_number (file, a - 1) + 1;
   *bptr = translate_line_number (file, b + 1) - 1;
@@ -1421,16 +636,16 @@ translate_range (struct file_data const
 void
 print_number_range (char sepchar, struct file_data *file, lin a, lin b)
 {
-  printint trans_a, trans_b;
+  long int trans_a, trans_b;
   translate_range (file, a, b, &trans_a, &trans_b);
 
   /* Note: we can have B < A in the case of a range of no lines.
      In this case, we should print the line number before the range,
      which is B.  */
   if (trans_b > trans_a)
-    fprintf (outfile, "%"pI"d%c%"pI"d", trans_a, sepchar, trans_b);
+    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
   else
-    fprintf (outfile, "%"pI"d", trans_b);
+    fprintf (outfile, "%ld", trans_b);
 }
 
 /* Look at a hunk of edit script and report the range of lines in each file
@@ -1448,8 +663,8 @@ print_number_range (char sepchar, struct
 
 enum changes
 analyze_hunk (struct change *hunk,
-              lin *first0, lin *last0,
-              lin *first1, lin *last1)
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
 {
   struct change *next;
   lin l0, l1;
@@ -1459,11 +674,8 @@ analyze_hunk (struct change *hunk,
   size_t trivial_length = ignore_blank_lines - 1;
     /* If 0, ignore zero-length lines;
        if SIZE_MAX, do not ignore lines just because of their length.  */
-
-  bool skip_white_space =
-    ignore_blank_lines && IGNORE_TRAILING_SPACE <= ignore_white_space;
   bool skip_leading_white_space =
-    skip_white_space && IGNORE_SPACE_CHANGE <= ignore_white_space;
+    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
 
   char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
   char const * const *linbuf1 = files[1].linbuf;
@@ -1482,46 +694,34 @@ analyze_hunk (struct change *hunk,
       show_to += next->inserted;
 
       for (i = next->line0; i <= l0 && trivial; i++)
-        {
-          char const *line = linbuf0[i];
-          char const *lastbyte = linbuf0[i + 1] - 1;
-          char const *newline = lastbyte + (*lastbyte != '\n');
-          size_t len = newline - line;
-          char const *p = line;
-          if (skip_white_space)
-            for (; *p != '\n'; p++)
-              if (! isspace ((unsigned char) *p))
-                {
-                  if (! skip_leading_white_space)
-                    p = line;
-                  break;
-                }
-          if (newline - p != trivial_length
-              && (! ignore_regexp.fastmap
-                  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
-            trivial = 0;
-        }
+	{
+	  char const *line = linbuf0[i];
+	  char const *newline = linbuf0[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
 
       for (i = next->line1; i <= l1 && trivial; i++)
-        {
-          char const *line = linbuf1[i];
-          char const *lastbyte = linbuf1[i + 1] - 1;
-          char const *newline = lastbyte + (*lastbyte != '\n');
-          size_t len = newline - line;
-          char const *p = line;
-          if (skip_white_space)
-            for (; *p != '\n'; p++)
-              if (! isspace ((unsigned char) *p))
-                {
-                  if (! skip_leading_white_space)
-                    p = line;
-                  break;
-                }
-          if (newline - p != trivial_length
-              && (! ignore_regexp.fastmap
-                  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
-            trivial = 0;
-        }
+	{
+	  char const *line = linbuf1[i];
+	  char const *newline = linbuf1[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
     }
   while ((next = next->link) != 0);
 
@@ -1556,6 +756,18 @@ zalloc (size_t size)
   memset (p, 0, size);
   return p;
 }
+
+/* Yield the newly malloc'd pathname
+   of the file in DIR whose filename is FILE.  */
+
+char *
+dir_file_pathname (char const *dir, char const *file)
+{
+  char const *base = last_component (dir);
+  size_t baselen = base_len (base);
+  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
+  return concat (dir, "/" + omit_slash, file);
+}
 
 void
 debug_script (struct change *sp)
@@ -1564,12 +776,12 @@ debug_script (struct change *sp)
 
   for (; sp; sp = sp->link)
     {
-      printint line0 = sp->line0;
-      printint line1 = sp->line1;
-      printint deleted = sp->deleted;
-      printint inserted = sp->inserted;
-      fprintf (stderr, "%3"pI"d %3"pI"d delete %"pI"d insert %"pI"d\n",
-               line0, line1, deleted, inserted);
+      long int line0 = sp->line0;
+      long int line1 = sp->line1;
+      long int deleted = sp->deleted;
+      long int inserted = sp->inserted;
+      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+	       line0, line1, deleted, inserted);
     }
 
   fflush (stderr);
